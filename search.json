[
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "The Modern Brains",
    "section": "",
    "text": "This week marked my first entry into microprocessors. Microprocessors are regarded as the brains of modern electronics and are at the center of each and every electronic we encounter in our lives from our daily smarphones to the vehicles we drive to our favorite venues everyday. The journey is exciting! The idea that I now get to be a “psychologist” (not the literal definition) as I work with and on machine brains is fascinating and I can’t wait for it. If you’re wondering what such a “Modern Brain” looks like, take a look at that beauty in the image below:\n\n\n\nsrc:phoenixnap.com\n\n\nAs exciting as the journey ahead looks like, it comes with its challenges. Long hours of hardwork and dedication, sleepless nights of debugging and setup adjustments, much of which I have started encountering at the moment with just 4 days in the class. Either way, I’m enjoying myself and I’m willing to do all it takes to learn, work, and innovate and make the most of the wonderful journey ahead.\n“Impara l’arte e mettila da parte!” (Learn the art and put it aside)."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab the FPGA was used to drive a Dual 7-segment display with the goal to demonstrate time multiplexing and how to efficiently use the I/O on our FPGA."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab the FPGA was used to drive a Dual 7-segment display with the goal to demonstrate time multiplexing and how to efficiently use the I/O on our FPGA."
  },
  {
    "objectID": "labs/lab2/lab2.html#experiment-setup-and-design-overview",
    "href": "labs/lab2/lab2.html#experiment-setup-and-design-overview",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display",
    "section": "Experiment Setup and Design Overview",
    "text": "Experiment Setup and Design Overview\nThe main task for the lab was to control the provided HDSP-521A dual 7-Segment display using only 7 pins from our FPGA. The FPGA received two different switch inputs from two different switch blocks, each meant to drive a specific 7-segment display. With limited hardware, the dual 7-segment pins had to share FPGA pins to drive the respective segment displaying the hex equivalent of the switch binary input. The FPGA outputted enablers meant to choose which display has to turn on by driving the respective common anodes HIGH. Each display responded to a respective switch block. Two 2N3906 PNP transistors were used to help drive large currents to the common anodes so as to avoid excessive current draw from the FPGA. An extra task was to show the sum of the two displayed digits using LEDs. These LEDs were also driven by the I/O pins from the FPGA.\n\nTime-multiplexing Logic\nTurning on 2 displays that share pins meant that we had to switch so fast that the two displays appear as if they are on at the same time wihout any flickering observed between them. To do this time multiplexing was used. Time multiplexing is a method in digital logic where different elements share common hardware resources for different purposes at different times. We had to implement a timing logic to achieve this task.\nThe human eye can detect flickering up to \\(\\sim60 Hz\\) (around \\(16.67 ms\\) per cycle). With two digits, this would mean that each must be active for at least 120 switches per second (60Hz * 2). To ensure “no flickering” switching between the two displays had to be every \\(\\sim8.3 ms\\) or less. I opted to switch at every \\(\\sim2 ms\\) which gives a \\(\\sim240 Hz\\) refresh rate (switching every \\(1*10^5\\) ticks), which is too fast for the human eye to detect. The module doing the switching leveraged the on-board high-speed oscillator as a clock frequency and used it to implement a counter that switched at the specified times. Another additional procedure to ensure no bleeding happens, all the displays were turned off for a brief time (500 clock cycles) to ensure there is no overlap by letting the transistors fully turn off. During the cooldown, the correct digit is loaded onto sevenSegIn, the display input, which is sent immediately when the counter completes and the dedicated segment turns on.\n\n\nDisplay and LED Control Logic\nAfter evey switching a specific display anode high using a 2-bit signal, onSeg[1:0], where MSB showed the state of the left display and LSB, the right display. This signal was multiplexed and used to select which switch input to send to the display that was activated. The left display was controlled by the on-board DIP switch module (sW1[3:0]), while the right one was controlled by the DIP switch component on the breadboard (sW2[3:0]). The selected input was sent to the dual 7-segment display to display the respective digit using the combinational logic module designed in LAB1.\nThe sum of the displayed numbers was calculated by simply performing binary addition of the two 4-bit switch inputs producing a 5-bit output. Each bit of the sum was relayed to a specific LED, giving us 5 different LEDs to show the binary representation of the sum. The modules to control these elements were written in SystemVerilog to run on the FPGA and to ensure proper communication and signal control, they all followed the hierachy in the block diagram below:\n\n\n\nFigure 1: Hierachical Block Diagram\n\n\nAfter running the simulation ensuring modules work as expected, the full setup was installed on a breadboard to control the dual 7-segment display and sum LEDs using the following schematic:\n\n\n\nFigure 2: FPGA Experiment Wiring Setup\n\n\nAs seen from the schematic, the sum LEDs are hooked up to \\(100\\Omega\\) resistors and the 7-segment display to \\(200\\Omega\\) resistors to ensure reasonable (safe) current draw from the FPGA.\nThe 7-segment display LEDs have a typical forward voltage drop of \\(\\approx1.70V\\). The target current draw per segment was \\(8mA\\) and the input voltage of \\(3.3V\\) from the FPGA, I calculated the desired resistor values using \\(R = \\frac{V_{\\text{in}} - V_{f}}{I_{des}}\\) obtaining that R should be \\(\\sim200\\Omega\\) where worst case scenario with all 14 segments on, the total load current is \\(112mA\\), much below FPGA rated max. Similar calculation was used for transistors with \\(V_{CE}\\approx0.7V\\) and a target \\(I_{BC}\\approx8mA\\), and the red sum LEDs with \\(V_F=1.80\\) and target current around \\(15mA\\). This gives \\(\\sim330\\Omega\\) and \\(100\\Omega\\) for the transistors and sum LEDs respectively."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench simulation\nSetting up the simulation was challenging due to the fact that the time multiplexing counter went on for too many cycles that the assert statements would finish before any switching was done making it hard to test the time multiplexing logic.\nMy first attempt was to create a fast clock so that counting happens so fast and could see switching. I adjusted my timescale to `timescale 1ns/1ps allowing me to create a clock with period of \\(0.2ns\\) (\\(50GHz\\)). This didn’t work as good because the simulation had to run for as long as \\(200ms\\) just to see a switch cycle. My final solution was to implemenet a parameter SWITCH_COUNT which allowed me to control the number of ticks outside the ledControl module. In my testbench I set SWITCH_COUNT = 1 which essentially switched enablers after 1 tick, equivalent to switching every clock cycle which solved my issue. Each module was simulated individually and running the simulation yielded the following waves:\n\n\n\nFigure 3: QuestaSim Screenshot Showing Time Multiplexing and LED Sum Simulation Outputs\n\n\n\n\n\nFigure 4: QuestaSim Screenshot Showing Waves For All 256 Possible Cases\n\n\nThe waves in Figure 3 above show that the the two displays turn on at different times as onSeg[1] and onSeg[1] oscillate oppositely. The waves shows that sevenSegIn chooses sW1 switch input when onSeg[1] is HIGH and sW1 input when switch onSeg[0] is HIGH showing the time multiplexing logic works. The LED sum also worked properly and was verified using the assert statement, executing all with no error returned.\n\n\n\nFigure 4: QuestaSim Screenshot Showing Seven-segment Display Simulation Outputs and Expected Outputs\n\n\nThe seven segment display also resopnds as expected.\n\n\nHardware Testing\nAll components were collected and assembled on an extended breadboard following the schematic in Figure 2. Using Radiant programmer, the code was uploaded to the FPGA to test the time multiplexing logic, the sum LEDs, and the 7-segment display. The hardware responded properly as shown in the example video below:\n\n\nVideo\nFigure 6: Hardware Execution Example Showing Outputs to Different Switch Inputs"
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nThis lab took around 25 hours to complete mainly because I had to go through a lot of debugging processes to fix and setup my testbench to properly illustrate time multiplexing. I solved the issue by learning how to deal with timing and synchronization issues and implementing a solution to modify the counter divider in my testbench. Another major issue was bleeding between the two displays which was caused by faulty adapter and FPGA pins probably damaged or due to poor soldering. I had to resolder most of them as a temporary fix but will look deeper into the issue as the bleeding is at its lowest but not completely gone. The lab was amazing overall and I learnt about time-multiplexing, a skill I believe will be useful in the future labs and projects of this class."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nI used Chatgpt 5 to run the prompt and it gave me the code below. The code was good except that syntheis didn’t work as the LLM was running a line `default_nettype none meant to set the global net parameter to none until all net parameters are specifically defined. Radiant wasn’t happy with that and as usual the LLM faught until it accepted that the best solution is to remove the line producing the next code that synthesized:\n//==============================================================\n// Hex -&gt; 7-seg decoder, common-anode, segments gfedcba (active-low)\n//==============================================================\nmodule seg7_decoder_ca (\n  input  logic [3:0] hex,\n  output logic [6:0] seg_n       // g f e d c b a, active-low\n);\n  always_comb begin\n    unique case (hex)\n      4'h0: seg_n = 7'b1000000; // 0\n      4'h1: seg_n = 7'b1111001; // 1\n      4'h2: seg_n = 7'b0100100; // 2\n      4'h3: seg_n = 7'b0110000; // 3\n      4'h4: seg_n = 7'b0011001; // 4\n      4'h5: seg_n = 7'b0010010; // 5\n      4'h6: seg_n = 7'b0000010; // 6\n      4'h7: seg_n = 7'b1111000; // 7\n      4'h8: seg_n = 7'b0000000; // 8\n      4'h9: seg_n = 7'b0010000; // 9\n      4'hA: seg_n = 7'b0001000; // A\n      4'hB: seg_n = 7'b0000011; // b\n      4'hC: seg_n = 7'b1000110; // C\n      4'hD: seg_n = 7'b0100001; // d\n      4'hE: seg_n = 7'b0000110; // E\n      4'hF: seg_n = 7'b0001110; // F\n      default: seg_n = 7'b1111111; // all off\n    endcase\n  end\nendmodule\n\n//==============================================================\n// Time-multiplex two digits using a single decoder.\n// - Common-anode digits, segments active-low (gfedcba).\n// - seg0_n drives left digit's 7 segment pins, seg1_n right's.\n// - digit_en_n are optional digit enables (active-low).\n// - Short blanking reduces ghosting when switching digits.\n//==============================================================\nmodule sevenseg_timemux2 #(\n  parameter int unsigned CLK_HZ      = 12_000_000, // FPGA clock (Hz)\n  parameter int unsigned FRAME_HZ    = 1000,       // full frames per second\n  parameter int unsigned BLANK_TICKS = 4           // blanking clocks per switch\n)(\n  input  logic        clk,\n  input  logic        reset,       // synchronous, active-high\n  input  logic [3:0]  hex0,        // left digit value\n  input  logic [3:0]  hex1,        // right digit value\n  output logic [6:0]  seg0_n,      // left  digit segments (gfedcba, active-low)\n  output logic [6:0]  seg1_n,      // right digit segments (gfedcba, active-low)\n  output logic [1:0]  digit_en_n   // {left,right} enables, active-low\n);\n\n  // ---- timing math (guard against tiny clocks/params) ----\n  localparam int unsigned HALF_FRAME_TICKS_RAW = (CLK_HZ / (2*FRAME_HZ));\n  localparam int unsigned HALF_FRAME_TICKS     = (HALF_FRAME_TICKS_RAW == 0) ? 1 : HALF_FRAME_TICKS_RAW;\n  localparam int unsigned SHOW_TICKS_RAW       = (HALF_FRAME_TICKS &gt; BLANK_TICKS) ? (HALF_FRAME_TICKS - BLANK_TICKS) : 1;\n  localparam int unsigned SHOW_TICKS           = (SHOW_TICKS_RAW == 0) ? 1 : SHOW_TICKS_RAW;\n\n  // Width for tick counter (&gt;=1)\n  localparam int unsigned TICK_W = (HALF_FRAME_TICKS &lt;= 1) ? 1 : $clog2(HALF_FRAME_TICKS);\n\n  typedef enum logic [1:0] {SHOW0, BLANK0, SHOW1, BLANK1} state_e;\n\n  state_e                 state, state_n;\n  logic [TICK_W-1:0]      tick,  tick_n;\n  logic [3:0]             mux_hex;\n  logic [6:0]             dec_seg_n;\n\n  // One shared decoder\n  seg7_decoder_ca u_dec (\n    .hex   (mux_hex),\n    .seg_n (dec_seg_n)\n  );\n\n  // Next-state / timer\n  always_comb begin\n    state_n = state;\n    tick_n  = tick + logic'(1);\n\n    unique case (state)\n      SHOW0:  if (tick == logic'(SHOW_TICKS - 1))  begin state_n = BLANK0; tick_n = '0; end\n      BLANK0: if (tick == logic'(BLANK_TICKS - 1)) begin state_n = SHOW1;  tick_n = '0; end\n      SHOW1:  if (tick == logic'(SHOW_TICKS - 1))  begin state_n = BLANK1; tick_n = '0; end\n      BLANK1: if (tick == logic'(BLANK_TICKS - 1)) begin state_n = SHOW0;  tick_n = '0; end\n      default: begin state_n = SHOW0; tick_n = '0; end\n    endcase\n  end\n\n  // State and counter registers\n  always_ff @(posedge clk) begin\n    if (reset) begin\n      state &lt;= SHOW0;\n      tick  &lt;= '0;\n    end else begin\n      state &lt;= state_n;\n      tick  &lt;= tick_n;\n    end\n  end\n\n  // Which nibble goes into the decoder?\n  always_comb begin\n    unique case (state)\n      SHOW0, BLANK0: mux_hex = hex0;\n      default      : mux_hex = hex1;\n    endcase\n  end\n\n  // Output driving with blanking\n  localparam logic [6:0] OFF = 7'b1111111; // all off (active-low)\n\n  always_comb begin\n    // defaults: blanked\n    seg0_n     = OFF;\n    seg1_n     = OFF;\n    digit_en_n = 2'b11; // both disabled (active-low)\n\n    unique case (state)\n      SHOW0: begin\n        seg0_n     = dec_seg_n;\n        digit_en_n = 2'b01; // left enabled (active-low), right disabled\n      end\n      SHOW1: begin\n        seg1_n     = dec_seg_n;\n        digit_en_n = 2'b10; // right enabled, left disabled\n      end\n      default: begin\n        // BLANK0 / BLANK1: keep both off\n        seg0_n     = OFF;\n        seg1_n     = OFF;\n        digit_en_n = 2'b11;\n      end\n    endcase\n  end\n\nendmodule\nThesecond prompt worked properly. I received two different files: one top module that istantiates the Lattice iCE40 high-freq oscillator and feeds the mux core, and a second module sevenSegTimeMux. It is a reusable core that takes a clock, two 4-bit values, and uses one sevenSegDispCtrl instance to alternately decode and latch the outputs into two 7-bit buses. This failed to synthesize because of the use of SB_HFOSC module siimilar to last week. To fix it, I had to specifically tell it to use HSOSC hf_osc as demosntrated in my files. However there was another issue where it was calling clk in the code but it didn’t instantiate the variable/logic. When I complained about the error, it would just suggest fixex not in the code the LLM gave me but in the files that I shared. I would have to specifically compalain about it’s code for changes, but still no changes but instead broken recommendations meant to “fix my code.” However, having done the AI Prototype summary earlier, I learned the trick of creating a forced off period while multiplexing the displays."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi! I’m Josaphat Ngoga, a senior Engineering major at Harvey Mudd College. My interests span both Mechanical and Electrical engineering, with a focus on mechanical design, electronics, and hardware systems. I enjoy working on projects that bring these areas together—especially those involving FPGA development and microcontroller-based applications. You can find more about my interests, skills, and projects at jngoga.vercel.app"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "The Modern Brains\n\n\nA journey to The Depths of Machine Psychology\n\n\n\n\n\nAug 29, 2025\n\n\nJosaphat Ngoga\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, an FPGA and MCU were installed on a development board setup and tested to verify proper functionality. The FPGA was later programmed to control a 7-segment display and a couple on-board LEDs based on a series of DIP switches. First, the development board was built by soldering on each individual components following BOM, schematic, and the silkscreen on the provided PCB."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, an FPGA and MCU were installed on a development board setup and tested to verify proper functionality. The FPGA was later programmed to control a 7-segment display and a couple on-board LEDs based on a series of DIP switches. First, the development board was built by soldering on each individual components following BOM, schematic, and the silkscreen on the provided PCB."
  },
  {
    "objectID": "labs/lab1/lab1.html#development-board-setup",
    "href": "labs/lab1/lab1.html#development-board-setup",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "Development Board Setup",
    "text": "Development Board Setup\nThe primary purpose of this lab was to assemble the development board to be used for the different labs and projects over the semester. The provided board was an empty PCB to be populated by different electrical components within the categories of Through Hole Technology (THT) as Surface Mount Technology (SMT). The electrical components provided were: resistors, capacitors, voltage regulator, DIP switches, push-button switches, jumpers, and LEDs. At the heart of the board there is the Nucleo-L432KC microcontroller unit (MCU) and the UPduino v3.1 FPGA which is the primary component handling the tasks of this lab.\nThe soldering process was straightforward except for the SMT components. It was hard to solder the voltage regulators because the underside plate was not sticking to the board fully. Surprisingly it was easy to solder the LEDs and other smaller SMT components probaly because I was just connecting to specific terminals as opposed to the wide plate of the voltage regulators. Due to inventory shortages, I was unable to install D1, the LED responsible to show if the board is powered on. The complete development board is shown below:\n\n\n\nFigure 1: Fully Assembled Development Board"
  },
  {
    "objectID": "labs/lab1/lab1.html#experiment-setup",
    "href": "labs/lab1/lab1.html#experiment-setup",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "Experiment Setup",
    "text": "Experiment Setup\nThe main task of the lab was to light up on-board LEDs and a HDSP-511A seven-segment display using one of the DIP switch modules on the development board. This was to be done using SystemVerilog modules uploaded to the FPGA module on the board.\n\nFPGA and MCU Testing\nBefore setting up for the actual experiment the FPGA and MCU, the brains of the whole board, were tested to ensure they work and can communicate to the respective components on the board they’re internally connected to. Determining if the board was powered on properly required some work without the red on-board VIN LED but I was able to read the input voltages from the regulators and the VIN pins using the tabletop multimeters in the lab space.\nUsing Lattice Radiant to program and upload the code to the FPGA, an onboard LED (D3) was toggled to blink at about 1HZ. Testing the MCU used a similar approach but Segger Embedded Studio was used to program the MCU where it blinked three on-board LEDs (D2, D3, and D7). These testing procedures worked out as expected indicating that the FPGA and MCU are integrated to the board correcltly.\n\n\nFPGA Experiment Design\nTo further test the board we had to drive two LEDs responding to the states of the four-DIP switch module. Based on the provided truth table, the first LED had to react to the first 2 DIP switches in a manner resembling an exclusive OR (XOR) gate. The second LED had to react to the last pair of DIP switches similar to an AND gate. These LEDs responded to their respective switch pair regardless of the other pair. The third LED to be controlled had to blink at about 2.4 Hz. This was done by leveraging the HSOSC module of the iCE40 Technology Library in Lattice Radiant. This allowed access to the on-board high speed oscillator providing 48MHz. Each cycle of third LED would last around 0.417 seconds meaning a full cycle requires around \\(\\approx2*10^7\\) ticks every second. With a 50% duty cycle it would take \\(10^7\\) ticks for the half cycle. This logic was used to design a flip flop that switched the state of the LED every \\(10^7\\) ticks (everytime the logic counter hit 10,000,000).\nThe second task was to setup a 7-segment display to display a single hexadecimal digit specified the binary state of the 4 DIP switches (shown as swDIP [3:0] in the code). The segments of the display share a common anode that is to be powered by 3.3V from the FPGA. Therefore to turn on the segments, a logic 0 was applied to the segment cathode line. Since we have a 4-bit switch state, it meant we could display all hex digits from 0x0 to 0xF. The modules to control these elements were written in SystemVerilog to run on the FPGA and to ensure proper communication and signal control, they all followed the hierachy in the block diagram below:\n\n\n\nFigure 2: Hierachical Block Diagram\n\n\nAfter running the simulation, the full setup was installed on a breadboard to visualize the actions of the on-board LEDs and to control the 7-segment display using the following schematic:\n\n\n\nFigure 3: FPGA Experiment Wiring Setup\n\n\nAs seen from the schematic, the on-board LEDs are hooked up to \\(1k\\Omega\\) resistors and the 7-segment display to \\(100\\Omega\\) resistors to ensure reasonable (safe) current draw from the FPGA.\nThe 7-segment display LEDs have a typical forward voltage drop of \\(\\approx2.00V\\). The FPGA limits the total current draw to \\(200mA\\). With a target current between \\(2-20mA\\) to drive the LEDs, and the input voltage of \\(3.3V\\) from the FPGA, I calculated the desired resistor values using \\(R = \\frac{V_{\\text{in}} - V_{f}}{I_{des}}\\) obtaining that R should be between \\(65-650\\Omega\\). I opted for the modest \\(100\\Omega\\) which draws \\(13mA\\) and is well within a range where the total current draw of the full display won’t overwhelm the FPGA."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench simulation\nSetting up the simulation was challenging due to different hurdles presented by Lattice Radiant, for example the tendency to sysnthesize the .tv file even though it’s not Verilog. The testbench also required a “timeprecision specification” which was fixed by adding the code `timescale 1ns/1ns to the top of the testbench code. Each module was simulated individually and running the simulation yielded the following waves:\n\n\n\nFigure 4: QuestaSim Screenshot Showing on-board LED Simulation Outputs and Expected Outputs\n\n\n\n\n\nFigure 5: QuestaSim Screenshot Showing Seven-segment Display Simulation Outputs and Expected Outputs\n\n\nAs shown from the simulation waves in Figures 4 and 5, the setup responded as expected which is a good sign.\n\n\nHardware Testing\nThe blinking LED could not be visualized using an automated testbench, Figure 6 below shows the oscilloscope trace indicating the LED is blinking at the desired \\(2.4Hz\\) and with a duty cycle of \\(50\\%\\).\n\n\n\nFigure 6: Oscilloscope Trace Showing Blinking LED\n\n\nUsing Radiant programmer, the code was uploaded to the FPGA to test the response of the on-board LEDs and the 7-segment display. The hardware responded properly as shown in the example figures below:\n\n\n\nFigure 7: Hardware Execution Example 1 Showing Outputs to Switch Input 4b’1101\n\n\n\n\n\nFigure 8: Hardware Execution Example 1 Showing Outputs to Switch Input 4b’1001"
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nThis lab took around 22 hours to complete mainly because I had to go through a lot of debugging processes to ensure my hardware works and connect to the board. In the end, it turned out to be the issue that I assigned hardware pin constraint to one of the SPI pins (Pin 12) which is used to connect to the FPGA. The lab was amazing overall and I was able to brush up my skills earned in E85."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nI used the new and updated LLM chatGPT 5.0 which is expected to be faster and smarter. After inputing the prompt, I received the following SystemVerilog code.\n// iCE40UP5K: Blink an LED at 2 Hz using the internal high-speed oscillator\n// Tooling: Yosys/nextpnr-ice40 or Radiant/Trellis\n`default_nettype none\n\nmodule top (\n    output logic LED   // constrain this to your chosen package pin in the .pcf/.lpf\n);\n    // ------------------------------------------------------------------------\n    // Internal high-speed oscillator (nominal 48 MHz with selectable dividers)\n    // CLKHF_DIV options (as strings):\n    //   \"0b00\" = 48 MHz, \"0b01\" = 24 MHz, \"0b10\" = 12 MHz, \"0b11\" = 6 MHz\n    // We'll use 12 MHz for a modest counter size.\n    // ------------------------------------------------------------------------\n    logic clk_hf;\n\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b10\")   // 12 MHz\n    ) u_hfosc (\n        .CLKHF   (clk_hf),\n        .CLKHFEN (1'b1),     // enable clock\n        .CLKHFPU (1'b1)      // power up\n    );\n\n    // ------------------------------------------------------------------------\n    // Blink at 2 Hz: toggle every half period (0.25 s)\n    // For a 12 MHz clock: cycles per toggle = 12_000_000 / (2*2) = 3_000_000\n    // ------------------------------------------------------------------------\n    localparam int unsigned CLOCK_HZ      = 12_000_000;\n    localparam int unsigned BLINK_HZ      = 2;\n    localparam int unsigned TOGGLE_CYCLES = CLOCK_HZ / (2 * BLINK_HZ);\n\n    // Counter width computed from the terminal count\n    localparam int unsigned CNT_W = (TOGGLE_CYCLES &gt; 1) ? $clog2(TOGGLE_CYCLES) : 1;\n\n    logic [CNT_W-1:0] cnt = '0;\n    logic             led_q = 1'b0;\n\n    always_ff @(posedge clk_hf) begin\n        if (cnt == TOGGLE_CYCLES-1) begin\n            cnt   &lt;= '0;\n            led_q &lt;= ~led_q;   // toggle LED every 0.25 s -&gt; 2 Hz blink\n        end else begin\n            cnt &lt;= cnt + 1'b1;\n        end\n    end\n\n    assign LED = led_q;\nendmodule\n\n`default_nettype wire\nThis code is well designed but it failed to synthesize because of the use of SB_HFOSC module. Radiant insisted it couldn’t find the module and the LLM kept on insisting I find it in my install files which I couldn’t. To fix it, I had to specifically tell it to use HSOSC hf_osc where the module synthesized properly.\n// Blink LED at 2 Hz using internal HSOSC (Radiant/LSE-friendly)\n`default_nettype none\n\nmodule top (\n    output logic LED\n);\n\n    // ------------------------------------------------------------------------\n    // HSOSC primitive (some Radiant/LSE setups expose this name).\n    // CLKHF_DIV: \"0b00\"=48 MHz, \"0b01\"=24 MHz, \"0b10\"=12 MHz, \"0b11\"=6 MHz\n    // ------------------------------------------------------------------------\n    localparam string DIV_SEL = \"0b10\"; // 12 MHz\n    logic clk_hf;\n\n    HSOSC hf_osc (\n        .CLKHF   (clk_hf),\n        .CLKHFEN (1'b1),\n        .CLKHFPU (1'b1)\n    );\n    defparam hf_osc.CLKHF_DIV = DIV_SEL;\n\n    // ------------------------------------------------------------------------\n    // 2 Hz blink (toggle every 0.25 s)\n    // ------------------------------------------------------------------------\n    localparam int unsigned CLOCK_HZ = (DIV_SEL==\"0b00\") ? 48_000_000 :\n                                       (DIV_SEL==\"0b01\") ? 24_000_000 :\n                                       (DIV_SEL==\"0b10\") ? 12_000_000 : 6_000_000;\n\n    localparam int unsigned BLINK_HZ      = 2;\n    localparam int unsigned TOGGLE_CYCLES = CLOCK_HZ / (2 * BLINK_HZ);\n    localparam int unsigned CNT_W         = (TOGGLE_CYCLES &gt; 1) ? $clog2(TOGGLE_CYCLES) : 1;\n\n    logic [CNT_W-1:0] cnt = '0;\n    logic             led_q = 1'b0;\n\n    always_ff @(posedge clk_hf) begin\n        if (cnt == TOGGLE_CYCLES-1) begin\n            cnt   &lt;= '0;\n            led_q &lt;= ~led_q;\n        end else begin\n            cnt &lt;= cnt + 1'b1;\n        end\n    end\n\n    assign LED = led_q;\nendmodule\n\n`default_nettype wire\nThe LLM used some new declarations that I didn’t understand so I had to ask it to explain more about them. For example the use of localparam ensures that the set variables stay within the module and can’t be altered by top level modules or other sub modules. Kinda like private in java. This also allowed the LLM to use numbers instead of writing every math in binary logic. The addition of `default_nettype wire ensures that SystemVerilog synthesis errors out when there is an undeclared identifier instead of declaring it as a wire which complicates the debugging process in case of an error. Next time I use an LLM I’d make sure to have a more specific prompt that specifies some things to use and other specifics to keep in mind."
  }
]