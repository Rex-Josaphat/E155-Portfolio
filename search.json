[
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "The Modern Brains",
    "section": "",
    "text": "This week marked my first entry into microprocessors. Microprocessors are regarded as the brains of modern electronics and are at the center of each and every electronic we encounter in our lives from our daily smarphones to the vehicles we drive to our favorite venues everyday. The journey is exciting! The idea that I now get to be a “psychologist” (not the literal definition) as I work with and on machine brains is fascinating and I can’t wait for it. If you’re wondering what such a “Modern Brain” looks like, take a look at that beauty in the image below:\n\n\n\nsrc:phoenixnap.com\n\n\nAs exciting as the journey ahead looks like, it comes with its challenges. Long hours of hardwork and dedication, sleepless nights of debugging and setup adjustments, much of which I have started encountering at the moment with just 4 days in the class. Either way, I’m enjoying myself and I’m willing to do all it takes to learn, work, and innovate and make the most of the wonderful journey ahead.\n“Impara l’arte e mettila da parte!” (Learn the art and put it aside)."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "E155 Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab, the MCU was used to interface with a temperature sensor based on the DS1772 chip via the SPI protocol. The MCU read the raw temperature data, decoded it, and transmitted the processed value to an ESP8266 module, which hosted a custom web interface. The website displayed the temperature values and allowed the user to adjust the measurement resolution all the way from a rounded whole number up to the accuracy within \\(\\frac{1}{16}\\). The web server also had the ability to control an onboard LED and display it’s status via commands sent directly from webpage. These features effectively implemented a functional IoT device combining sensing, data processing, wireless communication, and remote control."
  },
  {
    "objectID": "labs/lab6/lab6.html#introduction",
    "href": "labs/lab6/lab6.html#introduction",
    "title": "E155 Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab, the MCU was used to interface with a temperature sensor based on the DS1772 chip via the SPI protocol. The MCU read the raw temperature data, decoded it, and transmitted the processed value to an ESP8266 module, which hosted a custom web interface. The website displayed the temperature values and allowed the user to adjust the measurement resolution all the way from a rounded whole number up to the accuracy within \\(\\frac{1}{16}\\). The web server also had the ability to control an onboard LED and display it’s status via commands sent directly from webpage. These features effectively implemented a functional IoT device combining sensing, data processing, wireless communication, and remote control."
  },
  {
    "objectID": "labs/lab6/lab6.html#experiment-setup-and-design-overview",
    "href": "labs/lab6/lab6.html#experiment-setup-and-design-overview",
    "title": "E155 Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Experiment Setup and Design Overview",
    "text": "Experiment Setup and Design Overview\nThe main objective of this lab was to configure the onboard SPI protocol to interface correctly with the temperature sensor chip. This required implementing the appropriate SPI configuration functions and developing firmware drivers capable of interpreting web-based requests like resolution adjustments and temperature and decoding them into accurate temperature values. Communication with the ESP8266 was handled via onboard USART. The drivers for this function were provided to us in the starter code. However, we had to implement functions to remotely send temperature queries.\n\nDS1722 Sensor Setup Logic\nThe temperature sensor transmits data as an 8-bit stream over SPI. To read the temperature, the MCU first sends the 8-bit register address (either 0x01 or 0x02) followed by a dummy byte (0x00) to clock out the response from the sensor. MCU must perform two reads: one from 0x01 (MSB) and another from 0x02 (LSB), combining the bits and then decoding them into a decimal temperature value. Readings from 0x01 register stored the temperature as a two’s complement which was adjusted anytime we received negative readings. 0x02 stored fractional resolutions of the temperature reading.\nThe DS1722 supports 8, 9, 10, 11, and 12 bit resolution settings each corresponding to a number decimal digits and a specific decimal fraction with 8bit being a rounded whole number and 12bit a temperature reading with 4 decimal poin. The specific resolution was obtained using the website by clicking specific buttons, which sent a request to the MCU with specific resolution bits configured in the 0x02 register. If the resolution was above 8 bits, the MCU would adjust the temperature value using the expression ((lsb &gt;&gt; 4) & 0x0F) * 0.0625. This works because every bit in the 0x02 register corresponds to \\(\\frac{1}{16} = 0.0625\\). The resolution bits are stored in bits [7:4] which are left shifted and isolated using the and function. The resulting number is multiplied by the bit resolution to output the adjusted temperature. Our design used the sensors continous mode where the registers are regularly updated with new temperature. However this created a noticeable lag on the web requests especially for higher resolution requests because the temperature reading now had to change while being read. This added a latency in updating the resolution and when the temperature reading would be in that resolution.\n\n\nMCU Setup Logic\nThe MCU acts as a bridge connecting the functions on the board and the temperature sensor to the hosted webpage. The SPI1 mode was configured on the MCU by activating the APB2ENR peripheral clk. We then set the CR1 register to configure SPI1 settings such as setting the MCU as master, baud rate, clock phase and clock polarity. The baud rate was set to the maximum (0b111), which divides the input clock signal by 256. The clock polarity was 0 and phase set to 1 so that data changes on the rising edge of the clock. We also set full duplex and limited the size of transactions to 8 bits and the frame format to Motorolla mode. Before sending, the MCU would check if the transmit buffer is empty (checking if TXE flag is set), and then sent the 8 bits of data. In receiving, we implemented a pointer to pull out the necessary 8 bits and store tem for us to read. This was because the receiving register is 16 bits wide and we are only using 8. The MCU would continously check if the receiving buffer is full (checking if RXNE flag is set) and would return the recieved data. This implementation was concatenated in the function spiSendReceive(char send) that was used for any hardware SPI functionality.\nWe are using hardware SPI, which is equivalent to using the onboard functionality of the MCU to run SPI. This required to configure specific pins on the MCU so that it runs, otherwise there would be conflicts that would prevent communication to the DS1722 sometimes even hinder the USART connection to the ESP8266 which also required specifically pins A9 and A10."
  },
  {
    "objectID": "labs/lab6/lab6.html#hardware-setup-and-testing",
    "href": "labs/lab6/lab6.html#hardware-setup-and-testing",
    "title": "E155 Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Hardware Setup and Testing",
    "text": "Hardware Setup and Testing\nAfter verifying the MCU logic, the code was uploaded on the hardware for testing using Segger Embedded Studio. For the DS1722, we had to provide analog and digital supply voltages (\\(V_{DDA}\\) and \\(V_{DDD}\\) respectively) and power the Serial Interface Mode (\\(SERMODE\\)) to allow SPI. The other pins were connected to the respecive SPI lines from the MCU. The ESP8266 required power and connecting the Tx and Rx pins to the Rx and Tx pins on the MCU, respectively.\n\n\n\n\n\n\nFigure 1: DS1722 and ESP2866 Wiring Setup\n\n\n\nWhen we run the code, we are able to connect to the Wi-Fi generated by the ESP8266 and from here we can navigate to the hosted demo webpage where we find all the information and could send requests to change LED state or temeperature resolution bits.\n\n\n\n\n\n\nFigure 2: Demo Webpage\n\n\n\nTemperature is displayed up to 4 decimal places since the most resolution we can get, \\(0.0625\\), is 4 dp. To further test the hardware, I setup the logic analyzer to vizualize the SPI transactions between the MCU and the DS1722 temperature sensor. Below is an example of a transaction shown on the logic analyser\n\n\n\n\n\n\nFigure 3: Example SPI Transaction\n\n\n\nLooking at the bits on the MISO and MOSI lines, we can see that the sensor and the MCU are communicating succesfully. The MOSI line shows 80 E6 01 02 00 00: 0x80 is address of the write configuration register and the following 0xE6 byte sets the resolution and mode configuring the DS1722 to continous mode and 12-bit temperature resolution. The following 0x01 and 0x02 are temperature msb and lsb read commands while the 0x00 are the dummy bytes that the MCU sends so as to clock data from the temperature sensor. The MISO line shows FF FF FF A0 FF 17 which if full of the dummy bytes 0xFF and the MSB and LSB data 0xA0 and 0x17. Recalculating this gives me a temperature of \\(\\bf{\\approx29.8175^\\circ C}\\) which is reasonable."
  },
  {
    "objectID": "labs/lab6/lab6.html#conclusion",
    "href": "labs/lab6/lab6.html#conclusion",
    "title": "E155 Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Conclusion",
    "text": "Conclusion\nThis lab took around 27 hours to complete. I lost a lot of time debugging my communication protocols. The common issue is that there is a pin conflict that happens when the ESP8266 is in the dedicated slot on the development board. This meant that I had to define specific pins to execute USART and SPI properly. I also had errors in the way I had initialized SPI where wrong bitmasks were used and had missed other configs. These took a lot of time because it was always hard to tell if the issue is from the web, hardware, or the code declarations themselves. Extra time lost was from setting up the logic analyzer to vizualise my SPI transactions."
  },
  {
    "objectID": "labs/lab6/lab6.html#ai-prototype-summary",
    "href": "labs/lab6/lab6.html#ai-prototype-summary",
    "title": "E155 Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe goal was to use AI to generate a demo webpage, imitating the function of the current webpage that we used. Also the other function was to create a code to interface the DS1722 and ESP8266 using SPI and USART to compare and contrast the results and drawbacks of each approach.\nThe first prompt was to create a demo webpage and I received the following html code. The AI went all in in executing this website. It added CSS and added extra functionalities like unit conversion, LED blinking on demand, even adjusting how often temperature is polled from the sensor and updated on the web. The resuly was much better than the web style I implemented. I couldn’t use it for my work since it assumed I will be using specifc API from the chips instead of hardware communication thorugh SPI and USART. The rendered html provided the web below:\n\n\n\n\n\n\nFigure 4: AI Demo Webpage\n\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\" /&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt;\n  &lt;title&gt;Temperature Portal&lt;/title&gt;\n  &lt;style&gt;\n    :root {\n      --bg: #0b1020;\n      --card: #12182b;\n      --muted: #9aa3b2;\n      --accent: #5aa9ff;\n      --good: #22c55e;\n      --warn: #f59e0b;\n      --bad: #ef4444;\n    }\n    * { box-sizing: border-box; }\n    html, body { height: 100%; }\n    body {\n      margin: 0;\n      background: radial-gradient(1200px 800px at 20% 10%, #0f1732 0, var(--bg) 60%);\n      color: #e6eaf2;\n      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n      display: grid;\n      place-items: center;\n      padding: 24px;\n    }\n    .app {\n      width: 100%;\n      max-width: 980px;\n      display: grid;\n      gap: 20px;\n    }\n    header {\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n      gap: 16px;\n    }\n    .title {\n      display: flex;\n      align-items: baseline;\n      gap: 12px;\n    }\n    h1 { margin: 0; font-size: clamp(20px, 2.2vw + 10px, 32px); }\n    .badge {\n      font-size: 12px; letter-spacing: .3px; text-transform: uppercase;\n      color: var(--muted); border: 1px solid #2a3557; padding: 4px 8px; border-radius: 999px;\n    }\n    .grid { display: grid; grid-template-columns: 1.2fr .8fr; gap: 20px; }\n    @media (max-width: 800px) { .grid { grid-template-columns: 1fr; } }\n\n    .card {\n      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));\n      border: 1px solid rgba(255,255,255,.08);\n      border-radius: 16px;\n      padding: 18px;\n      box-shadow: 0 10px 30px rgba(0,0,0,.35);\n    }\n\n    /* Temperature display */\n    .temp-wrap { display: grid; gap: 12px; }\n    .temp-row {\n      display: grid; grid-template-columns: auto 1fr auto; align-items: end; gap: 12px;\n    }\n    .temp {\n      font-variant-numeric: tabular-nums; letter-spacing: .5px;\n      font-weight: 700;\n      font-size: clamp(44px, 7vw, 88px);\n      line-height: 1;\n    }\n    .units {\n      display: grid; gap: 8px; justify-items: end;\n    }\n    .pill {\n      display: inline-flex; align-items: center; gap: 8px; padding: 4px; border-radius: 999px;\n      background: #0e1630; border: 1px solid #273256;\n    }\n    .pill button { \n      appearance: none; border: 0; background: transparent; color: var(--muted);\n      padding: 6px 10px; border-radius: 999px; cursor: pointer; font-weight: 600;\n    }\n    .pill button.active { background: var(--accent); color: #041022; }\n\n    .sub {\n      font-size: 13px; color: var(--muted);\n    }\n    .row { display: flex; align-items: center; gap: 12px; }\n    .grow { flex: 1; }\n\n    .controls { display: grid; gap: 14px; }\n\n    /* Toggle switch */\n    .toggle {\n      position: relative; width: 60px; height: 34px; border-radius: 999px; background: #253153; border: 1px solid #2a3557; cursor: pointer; transition: background .2s ease;\n    }\n    .toggle::after {\n      content: \"\"; position: absolute; top: 3px; left: 3px; width: 28px; height: 28px; border-radius: 50%; background: white; transition: transform .2s ease;\n    }\n    .toggle[data-on=\"true\"] { background: #1b7642; border-color: #1b7642; }\n    .toggle[data-on=\"true\"]::after { transform: translateX(26px); }\n\n    .led-dot { width: 10px; height: 10px; border-radius: 50%; background: #3b435a; box-shadow: 0 0 0 2px #273256 inset; }\n    .led-dot.on { background: #44ff9a; box-shadow: 0 0 18px #44ff9a; }\n\n    select, button, input[type=\"number\"] {\n      appearance: none; border: 1px solid #2a3557; background: #0e1630; color: #e6eaf2; padding: 10px 12px; border-radius: 10px; font-weight: 600;\n    }\n    button.icon {\n      display: inline-flex; align-items: center; gap: 8px; cursor: pointer; background: #0e1630; border: 1px solid #2a3557; padding: 10px 12px; border-radius: 10px;\n    }\n    button.icon:hover { border-color: #3a4a7e; }\n\n    .status { font-size: 12px; color: var(--muted); display: flex; align-items: center; gap: 8px; }\n    .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--warn); box-shadow: 0 0 10px var(--warn); }\n    .dot.ok { background: var(--good); box-shadow: 0 0 10px var(--good); }\n    .dot.err { background: var(--bad); box-shadow: 0 0 10px var(--bad); }\n\n    footer { text-align: center; color: var(--muted); font-size: 12px; }\n    a { color: var(--accent); text-decoration: none; }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=\"app\" role=\"application\" aria-label=\"Temperature portal\"&gt;\n    &lt;header&gt;\n      &lt;div class=\"title\"&gt;\n        &lt;h1&gt;Temperature Portal&lt;/h1&gt;\n        &lt;span id=\"badge\" class=\"badge\" title=\"API mode\"&gt;Live&lt;/span&gt;\n      &lt;/div&gt;\n      &lt;div class=\"row\"&gt;\n        &lt;button id=\"refreshBtn\" class=\"icon\" title=\"Refresh now\" aria-label=\"Refresh temperature\"&gt;⟳ Refresh&lt;/button&gt;\n        &lt;select id=\"intervalSelect\" aria-label=\"Auto-refresh interval\"&gt;\n          &lt;option value=\"1000\"&gt;1s&lt;/option&gt;\n          &lt;option value=\"2000\" selected&gt;2s&lt;/option&gt;\n          &lt;option value=\"5000\"&gt;5s&lt;/option&gt;\n          &lt;option value=\"0\"&gt;Off&lt;/option&gt;\n        &lt;/select&gt;\n      &lt;/div&gt;\n    &lt;/header&gt;\n\n    &lt;div class=\"grid\"&gt;\n      &lt;section class=\"card temp-wrap\" aria-labelledby=\"tempHeading\"&gt;\n        &lt;div class=\"temp-row\"&gt;\n          &lt;div&gt;\n            &lt;div id=\"temp\" class=\"temp\" aria-live=\"polite\" aria-atomic=\"true\"&gt;--.–&lt;/div&gt;\n            &lt;div class=\"sub\"&gt;Last updated &lt;span id=\"updated\"&gt;—&lt;/span&gt;&lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div class=\"grow\"&gt;&lt;/div&gt;\n          &lt;div class=\"units\" aria-label=\"Precision and units\"&gt;\n            &lt;label class=\"sub\" for=\"precision\"&gt;Precision&lt;/label&gt;\n            &lt;select id=\"precision\" title=\"Change decimal precision\"&gt;\n              &lt;option value=\"0\"&gt;0 decimals&lt;/option&gt;\n              &lt;option value=\"1\"&gt;0.1&lt;/option&gt;\n              &lt;option value=\"2\" selected&gt;0.01&lt;/option&gt;\n              &lt;option value=\"3\"&gt;0.001&lt;/option&gt;\n              &lt;option value=\"4\"&gt;0.0001&lt;/option&gt;\n            &lt;/select&gt;\n            &lt;div class=\"pill\" role=\"group\" aria-label=\"Units\"&gt;\n              &lt;button id=\"unitC\" class=\"active\" aria-pressed=\"true\"&gt;°C&lt;/button&gt;\n              &lt;button id=\"unitF\" aria-pressed=\"false\"&gt;°F&lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=\"status\"&gt;&lt;span id=\"connDot\" class=\"dot\"&gt;&lt;/span&gt;&lt;span id=\"statusText\"&gt;Connecting…&lt;/span&gt;&lt;/div&gt;\n      &lt;/section&gt;\n\n      &lt;section class=\"card controls\" aria-labelledby=\"controlsHeading\"&gt;\n        &lt;h2 id=\"controlsHeading\" style=\"margin:0 0 6px\"&gt;Controls&lt;/h2&gt;\n        &lt;div class=\"row\" aria-live=\"polite\"&gt;\n          &lt;div class=\"grow\"&gt;\n            &lt;div class=\"sub\" id=\"ledLabel\"&gt;LED&lt;/div&gt;\n            &lt;div class=\"row\" style=\"margin-top:6px; align-items:center; gap:12px\"&gt;\n              &lt;div id=\"ledSwitch\" class=\"toggle\" role=\"switch\" aria-checked=\"false\" tabindex=\"0\"&gt;&lt;/div&gt;\n              &lt;div id=\"ledDot\" class=\"led-dot\" aria-hidden=\"true\"&gt;&lt;/div&gt;\n              &lt;div id=\"ledState\" class=\"sub\"&gt;Off&lt;/div&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;button id=\"blinkBtn\" class=\"icon\" title=\"Blink 3×\"&gt;\n            ✦ Blink 3×\n          &lt;/button&gt;\n        &lt;/div&gt;\n        &lt;div class=\"sub\"&gt;Tip: Space/Enter toggles the LED when the switch is focused.&lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/div&gt;\n\n    &lt;footer&gt;Editable single-file UI • Hook your endpoints in &lt;code&gt;API&lt;/code&gt; below&lt;/footer&gt;\n  &lt;/div&gt;\n\n  &lt;script&gt;\n    /**\n     * === API ENDPOINTS ===\n     * Replace these with your actual routes.\n     * Expected payloads:\n     *   GET  /api/temperature  -&gt; { temperature: number } in Celsius\n     *   GET  /api/led          -&gt; { state: boolean }\n     *   POST /api/led          -&gt; { state: boolean } with JSON body { state }\n     *   POST /api/led/blink    -&gt; { ok: true }\n     */\n    const API = {\n      temp: \"/api/temperature\",\n      led: \"/api/led\",\n      blink: \"/api/led/blink\",\n    };\n\n    // --- DOM refs ---\n    const el = {\n      temp: document.getElementById('temp'),\n      updated: document.getElementById('updated'),\n      precision: document.getElementById('precision'),\n      unitC: document.getElementById('unitC'),\n      unitF: document.getElementById('unitF'),\n      statusText: document.getElementById('statusText'),\n      connDot: document.getElementById('connDot'),\n      badge: document.getElementById('badge'),\n      interval: document.getElementById('intervalSelect'),\n      refreshBtn: document.getElementById('refreshBtn'),\n      ledSwitch: document.getElementById('ledSwitch'),\n      ledDot: document.getElementById('ledDot'),\n      ledState: document.getElementById('ledState'),\n      blinkBtn: document.getElementById('blinkBtn'),\n    };\n\n    // --- State ---\n    let state = {\n      celsius: NaN,        // last raw Celsius value\n      precision: +(localStorage.getItem('precision') ?? 2),\n      unit:   localStorage.getItem('unit') ?? 'C',\n      intervalMs: +(localStorage.getItem('interval') ?? 2000),\n      demo: false,\n    };\n\n    // helpers\n    const fmtTime = (d) =&gt; d.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit', second: '2-digit'});\n    const cToF = (c) =&gt; (c * 9/5) + 32;\n\n    function renderTemp() {\n      if (Number.isNaN(state.celsius)) { el.temp.textContent = '--.–'; return; }\n      const val = state.unit === 'C' ? state.celsius : cToF(state.celsius);\n      const fixed = val.toFixed(state.precision);\n      el.temp.textContent = `${fixed} °${state.unit}`;\n    }\n\n    function setStatus(kind, msg) {\n      el.statusText.textContent = msg;\n      el.connDot.classList.remove('ok', 'err');\n      if (kind === 'ok') el.connDot.classList.add('ok');\n      if (kind === 'err') el.connDot.classList.add('err');\n    }\n\n    // --- Fetch with timeout ---\n    async function fetchJSON(url, opts = {}, timeoutMs = 1500) {\n      const ctrl = new AbortController();\n      const t = setTimeout(() =&gt; ctrl.abort(), timeoutMs);\n      try {\n        const res = await fetch(url, { ...opts, signal: ctrl.signal, headers: { 'Content-Type': 'application/json', ...(opts.headers||{}) } });\n        if (!res.ok) throw new Error(`HTTP ${res.status}`);\n        return await res.json();\n      } finally {\n        clearTimeout(t);\n      }\n    }\n\n    // --- Temperature polling ---\n    let pollTimer = null;\n    async function readTemperature() {\n      try {\n        const data = await fetchJSON(API.temp);\n        if (state.demo) toggleDemo(false);\n        state.celsius = Number(data.temperature);\n        renderTemp();\n        el.updated.textContent = fmtTime(new Date());\n        setStatus('ok', 'Live');\n      } catch (e) {\n        // enter demo mode on first failure\n        if (!state.demo) toggleDemo(true);\n        // simulate a drifting temperature for demo\n        const t = Date.now() / 1000;\n        state.celsius = 23 + Math.sin(t/6) * 1.3 + Math.cos(t/4) * 0.7;\n        renderTemp();\n        el.updated.textContent = fmtTime(new Date());\n        setStatus('err', 'Demo mode (API unreachable)');\n      }\n    }\n\n    function startPolling() {\n      stopPolling();\n      if (state.intervalMs &gt; 0) {\n        pollTimer = setInterval(readTemperature, state.intervalMs);\n      }\n    }\n    function stopPolling() { if (pollTimer) { clearInterval(pollTimer); pollTimer = null; } }\n\n    function toggleDemo(on) {\n      state.demo = !!on;\n      el.badge.textContent = on ? 'Demo' : 'Live';\n      el.badge.title = on ? 'Simulated data' : 'API mode';\n    }\n\n    // --- LED ---\n    async function getLED() {\n      try {\n        const data = await fetchJSON(API.led);\n        setLED(!!data.state);\n      } catch (e) {\n        // If API fails, reflect current UI state and keep going\n      }\n    }\n    function setLED(on) {\n      el.ledSwitch.dataset.on = String(!!on);\n      el.ledSwitch.setAttribute('aria-checked', String(!!on));\n      el.ledDot.classList.toggle('on', !!on);\n      el.ledState.textContent = on ? 'On' : 'Off';\n    }\n    async function sendLED(on) {\n      setLED(on); // optimistic\n      try {\n        await fetchJSON(API.led, { method: 'POST', body: JSON.stringify({ state: !!on }) });\n      } catch (e) {\n        // revert on failure\n        setLED(!on);\n      }\n    }\n\n    async function blinkLED() {\n      el.blinkBtn.disabled = true;\n      try { await fetchJSON(API.blink, { method: 'POST', body: JSON.stringify({ times: 3 }) }); }\n      catch (e) {}\n      finally { el.blinkBtn.disabled = false; }\n    }\n\n    // --- Wire up UI ---\n    function applyPrecision(p) {\n      state.precision = Math.max(0, Math.min(6, Number(p)||0));\n      localStorage.setItem('precision', String(state.precision));\n      el.precision.value = String(state.precision);\n      renderTemp();\n    }\n\n    function applyUnit(u) {\n      state.unit = (u === 'F') ? 'F' : 'C';\n      localStorage.setItem('unit', state.unit);\n      el.unitC.classList.toggle('active', state.unit === 'C');\n      el.unitF.classList.toggle('active', state.unit === 'F');\n      el.unitC.setAttribute('aria-pressed', String(state.unit === 'C'));\n      el.unitF.setAttribute('aria-pressed', String(state.unit === 'F'));\n      renderTemp();\n    }\n\n    function applyInterval(ms) {\n      state.intervalMs = Math.max(0, Number(ms)||0);\n      localStorage.setItem('interval', String(state.intervalMs));\n      el.interval.value = String(state.intervalMs);\n      startPolling();\n    }\n\n    // keyboard toggle for accessibility\n    el.ledSwitch.addEventListener('click', () =&gt; sendLED(el.ledSwitch.dataset.on !== 'true'));\n    el.ledSwitch.addEventListener('keydown', (e) =&gt; {\n      if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); sendLED(el.ledSwitch.dataset.on !== 'true'); }\n    });\n\n    el.precision.addEventListener('change', (e) =&gt; applyPrecision(e.target.value));\n    el.unitC.addEventListener('click', () =&gt; applyUnit('C'));\n    el.unitF.addEventListener('click', () =&gt; applyUnit('F'));\n    el.interval.addEventListener('change', (e) =&gt; applyInterval(e.target.value));\n    el.refreshBtn.addEventListener('click', readTemperature);\n    el.blinkBtn.addEventListener('click', blinkLED);\n\n    // --- Init ---\n    (function init() {\n      applyPrecision(state.precision);\n      applyUnit(state.unit);\n      applyInterval(state.intervalMs);\n      // prime UI\n      renderTemp();\n      getLED();\n      readTemperature();\n    })();\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nThe second prompt required the LLM to create a CMSIS based SMT32 SPI driver to interface the DS1722 sensor. I didn’t run the code but I can see that the functions it generated and the bit manipulation performed mathces what I had. Especially for initializing and configuring SPI and sending and receiving from SPI.\n#include \"stm32l432xx.h\"\n#include &lt;stdint.h&gt;\n\n// =========================\n// DS1722 SPI COMMANDS\n// =========================\n#define DS1722_READ_TEMP_MSB  0xAA  // Read MSB temperature register\n#define DS1722_READ_TEMP_LSB  0xA1  // Read LSB temperature register\n\n// =========================\n// PIN & SPI DEFINITIONS\n// =========================\n#define DS1722_SPI            SPI1\n#define DS1722_CS_LOW()       (GPIOA-&gt;BSRR = (1U &lt;&lt; (4 + 16)))  // PA4 low\n#define DS1722_CS_HIGH()      (GPIOA-&gt;BSRR = (1U &lt;&lt; 4))         // PA4 high\n\n// =========================\n// SPI1 INITIALIZATION\n// =========================\nvoid SPI1_Init(void) {\n    // --- Enable peripheral clocks ---\n    RCC-&gt;AHB2ENR  |= RCC_AHB2ENR_GPIOAEN;   // Enable GPIOA\n    RCC-&gt;APB2ENR  |= RCC_APB2ENR_SPI1EN;    // Enable SPI1\n\n    // --- Configure GPIO pins ---\n    // PA4 = NSS (manual CS)\n    // PA5 = SCK, PA6 = MISO, PA7 = MOSI\n    GPIOA-&gt;MODER &= ~((3U &lt;&lt; (4*2)) | (3U &lt;&lt; (5*2)) | (3U &lt;&lt; (6*2)) | (3U &lt;&lt; (7*2)));\n    GPIOA-&gt;MODER |=  (2U &lt;&lt; (5*2)) | (2U &lt;&lt; (6*2)) | (2U &lt;&lt; (7*2));   // AF mode for SCK/MISO/MOSI\n    GPIOA-&gt;AFR[0]  &= ~((0xF &lt;&lt; (5*4)) | (0xF &lt;&lt; (6*4)) | (0xF &lt;&lt; (7*4)));\n    GPIOA-&gt;AFR[0]  |=  (5U &lt;&lt; (5*4)) | (5U &lt;&lt; (6*4)) | (5U &lt;&lt; (7*4)); // AF5 = SPI1\n    GPIOA-&gt;MODER   |=  (1U &lt;&lt; (4*2));                                // PA4 as GPIO output (manual CS)\n    DS1722_CS_HIGH();\n\n    // --- Configure SPI1 ---\n    // Master mode, baud rate = fPCLK/16, CPOL=0, CPHA=0, 8-bit data, software NSS\n    DS1722_SPI-&gt;CR1 = SPI_CR1_MSTR | SPI_CR1_SSM | SPI_CR1_SSI | (3U &lt;&lt; SPI_CR1_BR_Pos);\n    DS1722_SPI-&gt;CR2 = 0; // 8-bit data frame\n    DS1722_SPI-&gt;CR1 |= SPI_CR1_SPE; // Enable SPI\n}\n\n// =========================\n// SPI SEND/RECEIVE BYTE\n// =========================\nstatic uint8_t SPI_TransmitReceive(uint8_t data) {\n    while (!(DS1722_SPI-&gt;SR & SPI_SR_TXE));      // Wait until TX buffer empty\n    *((__IO uint8_t *)&DS1722_SPI-&gt;DR) = data;   // Send data\n    while (!(DS1722_SPI-&gt;SR & SPI_SR_RXNE));     // Wait until RX buffer full\n    return *((__IO uint8_t *)&DS1722_SPI-&gt;DR);   // Return received data\n}\n\n// =========================\n// READ TEMPERATURE (°C)\n// =========================\nfloat DS1722_ReadTemperature(void) {\n    uint8_t msb, lsb;\n    int16_t raw;\n\n    DS1722_CS_LOW();\n\n    // --- Read MSB register ---\n    SPI_TransmitReceive(DS1722_READ_TEMP_MSB);\n    msb = SPI_TransmitReceive(0x00);\n\n    // --- Read LSB register ---\n    SPI_TransmitReceive(DS1722_READ_TEMP_LSB);\n    lsb = SPI_TransmitReceive(0x00);\n\n    DS1722_CS_HIGH();\n\n    // --- Combine MSB & LSB into signed 13-bit value ---\n    raw = ((int16_t)msb &lt;&lt; 8) | lsb;\n    raw &gt;&gt;= 3; // right-align 13 bits\n\n    // --- Convert to °C (0.0625 °C per bit) ---\n    return (float)raw * 0.0625f;\n}\n\n// =========================\n// MAIN PROGRAM\n// =========================\nint main(void) {\n    SPI1_Init();\n    float tempC;\n\n    while (1) {\n        tempC = DS1722_ReadTemperature();\n        // Here you can send `tempC` to UART, LCD, or a web server\n        // Example: printf(\"Temperature: %.2f °C\\\\r\\\\n\", tempC);\n\n        // Small delay (approx 0.5s at 80 MHz)\n        for (volatile int i = 0; i &lt; 4000000; i++);\n    }\n}"
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "E155 Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab the STM32L432KC Microcontroller Unit (MCU) was used to play music on a speaker. The MCU did this by generating a square wave at a specific frequency for a specific duration. The system was able to play Für Elise by Beethoven and Faded by Alan Walker as part of testing the functionality."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "E155 Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab the STM32L432KC Microcontroller Unit (MCU) was used to play music on a speaker. The MCU did this by generating a square wave at a specific frequency for a specific duration. The system was able to play Für Elise by Beethoven and Faded by Alan Walker as part of testing the functionality."
  },
  {
    "objectID": "labs/lab4/lab4.html#experiment-setup-and-design-overview",
    "href": "labs/lab4/lab4.html#experiment-setup-and-design-overview",
    "title": "E155 Lab 4: Digital Audio",
    "section": "Experiment Setup and Design Overview",
    "text": "Experiment Setup and Design Overview\nThe main purpose of the lab was to learn how to read the manual and figure out how to set up different peripherals and the I/O of the MCU to perform the desired function. This includes initializing the proper structures and logic which are essential to run functions and extract performance out of the MCU. The MCU was set up to read a program containing a list of notes (shown as their frequency in Hz) and duration (shown in ms) to play the desired music.\n\nMCU Setup Logic\nTo set up the MCU for the desired function, we had to configure different modules to run the system clock, set up timers, pre-flash functions, and configure the GPIO to use. To do this, we had to set up respective Header files to interface these functionalities. The header files setup were: RCC.h,the Reset & Clock Control (RCC) module to set up the system clock; GPIO.h, used to configure GPIO functions and enable parameters for other peripherals and TIM6_7.h, used to setup and configure parameters for the basic timers.\nThe MCU features timers that have specific channels for PWM generation (TIM2, TIM3, TIM15, & TIM16). They can be configured for PWM using output compare mode (CCR) and different prescaler values and auto-reload settings (ARR) to set up PWM frequencies and duty cycle. This approach was a challenge for me in terms of configuring the relevant registers and structures to perform PWM on TIM15 or TIM16 properly. The major issue is that if one bit is configured wrong, it renders a register useless, and this will yield no output on the circuit; it was hard for me to debug even with an oscilloscope. I elected to use the basic timers TIM6 and TIM7 to perform the tasks for this lab, which was simpler as I had full control over the behaviour of the counters. The main idea was to configure each timer’s prescaler and ARR so that the counters overflow at predictable intervals and then constantly check the timer’s status register (SR) for when the UIF bit is set. For delays, TIM6 runs until it overflows at the desired duration, at which point the UIF is cleared to acknowledge completion. For PWM generation, TIM7 is configured to overflow at half of the desired wave period, which is used to time each high- and low-phase of the square wave.\n\n\nImplementation\nEach timer is driven by the system clock (4MHz) and is divided using the AHB prescaler down to 1MHz to set the peripheral clock (HCLK) for all timers, following the equation below:\n\\[\n\\text{HCLK} = \\frac{\\text{SYSCLK}}{\\text{AHB Factor}} = \\frac{\\text{4MHz}}{4} = \\text{1MHz}\n\\tag{1}\\]\nThe HCLK was further divided down to set the counter frequency of TIM6 to 1kHz, meaning that each tick was exactly 1ms. This scaling allowed me to implement the delay functionality by setting ARR = dur – 1, where dur is the desired frequency duration, and waiting until the UIF flag is raised. TIM6 count frequency was obtained by setting TIM6 prescaler (PSC) to PSC = 999 as shown below:\n\\[\nf_\\text{TIM6} = \\frac{\\text{HCLK}}{(\\text{PSC}+1)} = \\frac{\\text{1MHz}}{(999+1)} = \\text{1kHz}\n\\tag{2}\\]\nFor PWM generation, both TIM6 and TIM7 are used together. TIM6 measures the total pulse duration by overflowing after dur milliseconds. Since we configured TIM7 to drive a PWM output in toggle mode, the hardware toggles the output every overflow. This means that the output signal is two overflows long (one rising and one falling edge). Therefore, to generate the desired frequency, TIM7 is configured to overflow every half-period of the desired frequency (run at twice the desired frequency), given a 1MHz timer frequency as shown below:\n\\[\nT_\\text{half} = \\frac{1}{2f_\\text{PWM}} = \\frac{1,000,000}{2 f_\\text{PWM}} \\text{µs}\n\\tag{3}\\]\nThis is used to time each high- and low-phase of the square wave. Inside the PWM loop, the GPIO pin is driven high for one half-period, then low for the next half-period, with each phase timed by constantly checking UIF on TIM7, the wave timer. The process continues until UIF on TIM6 indicates that the total duration has expired. Suppose the overall delay timer finishes in the middle of a PWM cycle. In that case, the code breaks out instead of doing another half-period, essentially handling one of the edge cases in PWM generation. Also, the UIF bit is cleared after each wait, ensuring the next period is measured accurately.\nThis logic avoids system interrupts because the UIF is polled directly, allowing all control to be done in software. This keeps the CPU busy through wait loops, limiting it to only one function, as this also makes debugging easier. This works for this lab, as the CPU doesn’t need to perform any other functions simultaneously or otherwise, I would have to use interrupts."
  },
  {
    "objectID": "labs/lab4/lab4.html#verification-of-timer-limits-and-edge-cases",
    "href": "labs/lab4/lab4.html#verification-of-timer-limits-and-edge-cases",
    "title": "E155 Lab 4: Digital Audio",
    "section": "Verification of Timer Limits and Edge Cases",
    "text": "Verification of Timer Limits and Edge Cases\n\nDelay Limits\nThe delay timer, TIM6, runs at a counter frequency of \\(1kHz\\), where one tick is equivalent to \\(1ms\\). The overflow period for the timer is obtained through:\n\\[\nt_\\text{delay} = \\frac{(ARR + 1)}{f_\\text{TIM6}}\n\\tag{4}\\]\n\nThe minimum delay can only be achieved when ARR = 0 since it can never be negative. Therefore:\n\n\\[\nt_\\text{delay} = \\frac{(0 + 1)}{\\text{1kHz}} = 1ms\n\\tag{5}\\]\n\nTIM6 has a 16-bit counter, therefore maximum delay can only be achieved when ARR = 65,535. Therefore:\n\n\\[\nt_\\text{delay} = \\frac{(65535 + 1)}{\\text{1kHz}} = 65.536s\n\\tag{6}\\]\nWith a counter frequency of \\(1 kHz\\), TIM6 supports a duration within the range of 1 ms to 65.536 s, with 1 ms resolution, which is more than enough for the desired application in this lab.\n\n\nPWM Frequency Limits\nThe PWM wave timer, TIM7, runs at HCLK which is \\(1MHz\\) and is toggled on each overflow. As mentioned before in the Implementation section above, TIM7 has to toggle at twice the desired rate to ensure the output square wave comes out as desired. The frequency of the toggled square wave is determined by Equation 7 below:\n\\[\nf_\\text{PWM} = \\frac{\\text{HCLK}}{2(ARR + 1)}\n\\tag{7}\\]\n\nEquation 7 above shows that the PWM frequency is inversely proportional to ARR. Therefore minimum toggle frequency exists at the maximum possible ARR value, ARR = 65,535. Therefore:\n\n\\[\nf_\\text{PWM} = \\frac{1,000,000}{2(65535 + 1)} = 7.629Hz\n\\tag{8}\\]\n\nFollowing similar logic, maximum toggle frequency exists at the minimum possible ARR value, ARR = 0. Therefore:\n\n\\[\nf_\\text{PWM} = \\frac{1,000,000}{2(0 + 1)} = 500kHz\n\\tag{9}\\]\nWith a timer frequency of \\(1MHz\\), TIM7 supported frequencies range calculated above encompasses the desired frequency range of 220Hz to 1000Hz sufficient for our applications.\n\n\nSong Playing Accuracy\nThe durations were pretty much accurate because TIM6 was confugured with a period in milliseconds. The desired duration was directly equivalent to the ARR used in Equation 4. The ARR input into the equation was calculated using the equation below:\n\\[\n\\text{ARR} = \\text{duration} - 1\n\\tag{10}\\]\nThis meant that going into calculations the period divider was equivalent to the actual millisecond delay desired.\nFor the frequencies, the ARR input into TIM7 was calculated using the half-frequency division to allow running both rising and falling edges of the square wave within the timing window set by the delay. It was obtained using the following equation:\n\\[\n\\text{ARR} = \\frac{\\text{HCLK}}{2f_\\text{PWM}} - 1\n\\tag{11}\\]\n\nIf the desired frequency was 220Hz then, Equation 11 gives \\(ARR\\approx 2272\\). Substituting this in Equation 7 gives toggle frequency, \\(f_\\text{toggle} = 219.97Hz\\), equivalent to a 0.014% error.\nIf the desired frequency was 1000Hz then, Equation 11 gives \\(ARR\\approx 499\\). Substituting this in Equation 7 gives toggle frequency, \\(f_\\text{toggle} = 1000Hz\\), equivalent to a 0.00% error.\n\nThis proves that individual pitches are accurate within 1% across the frequency range of 220-1000 Hz as desired, therefore verifying precision and accuracy of the design."
  },
  {
    "objectID": "labs/lab4/lab4.html#hardware-testing-and-results",
    "href": "labs/lab4/lab4.html#hardware-testing-and-results",
    "title": "E155 Lab 4: Digital Audio",
    "section": "Hardware Testing and Results",
    "text": "Hardware Testing and Results\nAfter verifying the MCU logic, the code was uploaded on the hardware for testing using Segger Embedded Studio. The setup used onboard switches connected to pins A7 and A4 of the MCU. These pins were used to switch between the two available songs. The switches were configured by activating the onboard \\(10k\\Omega\\) pull-up resistors through the dedicated PURPDR GPIO function. The MCU toggle output through pin A7 was fed into a \\(10k\\Omega\\) potentiometer for volume control, which sent it to the non-inverting input of the LM386 op-amp. The ouput of the op-amp (analog signal) went to the speaker to play the chosen song. All components were collected and assembled on an extended breadboard following the schematic below:\n\n\n\n\n\n\nFigure 1: MCU Experiment Wiring Setup\n\n\n\nThe hardware responded properly as shown in the example video below:\n\n\n\nVideo\n\n\nFigure 2: Hardware Execution Example Playing Songs and Adjusting Volume"
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "E155 Lab 4: Digital Audio",
    "section": "Conclusion",
    "text": "Conclusion\nThis lab took around 19 hours to complete. A lot of time was spent figuring out how to set up the proper registers for timers as well as other functions I epected to use with my MCU. It was also hard to debug since unlike the FPGA, when anything is wrong, you don’t get any output which is different from the FPGA where you get a wrong output and could debug from there. The errors I found were through register instantiation and some typos like negative signs in the implementation that were not caught by the compiler. Resolving all of this allowed me to get my hardware playing music properly."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype-summary",
    "href": "labs/lab4/lab4.html#ai-prototype-summary",
    "title": "E155 Lab 4: Digital Audio",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe goal of this prototype is using AI as a documentation search assistant to navigate memory maps and guide the configuration of various peripherals. I used Chatgpt 5 to run the different prompts and it gave me the following results:\n\nThe AI was able to recognisze the different types of registers that could be used, identified the pros and cons of using either, and also managed to predict the full course all the way from instantiating registers to implementing CCR, prescaler, and ARR functionality. However this was after I passed the STM32L4 reference manual along with the prompt. Figure 3 below shows this initial realization:\n\n\n\n\n\n\n\nFigure 3: Example Timers Identified by The LLM.\n\n\n\n\nAfter Identifying potential timers to use for the desired PWM generation, the LLM also correctly identified how to calculate the ARR, frequency, duty cycle, and necessary prescalers to perform the functions. Figure 4 below shows this implementation:\n\n\n\n\n\n\n\nFigure 4: Explanations and Calculations Necessary to Find Parameters of the PWM.\n\n\n\n\nAfter correctly identifying the timers, the LLM went on to initalize all the necessary registers in proper steps. Figure 5 below shows this implementation:\n\n\n\n\n\n\n\nFigure 5: Register Instantiation for GP Timers TIM2/TIM3.\n\n\n\n\nHere is also an example provided to show the use of the different register declarations. This shows me that the LLM got the idea on what to do and how to setup to achieve the desired frequency RPM and durations as shown in Figure 6 below:\n\n\n\n\n\n\n\nFigure 6: Example ARR and PRSC values Calculation.\n\n\n\n\nLastly, the LLM provided an example code to show how it could drive the pins to generate a frequency. The code enables timers, configures GPIO, ARR and Prescalers, the code also implements a ms delay function to ensure separation between different frequencies driven.\n\n// Simple PWM tone generator on STM32L432KC\n// Output: PA0 = TIM2_CH1 (AF1)\n// Freq range: 220 Hz – 1 kHz (works for others too)\n// Toolchain: bare-metal with CMSIS headers\n\n#include \"stm32l4xx.h\"\n\n#define TIM2CLK_HZ   80000000UL   // Adjust if your clock tree differs\n#define TARGET_TICK  1000000UL    // We prescale timer to 1 MHz for easy math (1 tick = 1 us)\n\nstatic inline void tim2_set_freq(uint32_t freq_hz) {\n    if (freq_hz == 0) {\n        // Stop output\n        TIM2-&gt;CCER &= ~TIM_CCER_CC1E;\n        return;\n    }\n\n    // With timer tick at 1 MHz, ARR = (1e6 / f) - 1\n    uint32_t arr = (TARGET_TICK / freq_hz) - 1U;\n    if (arr &lt; 1) arr = 1;  // guard\n\n    // Use 50% duty: CCR1 = (ARR+1)/2\n    uint32_t ccr = (arr + 1U) / 2U;\n\n    // Update safely using preload + UG\n    TIM2-&gt;ARR  = arr;\n    TIM2-&gt;CCR1 = ccr;\n    TIM2-&gt;EGR  = TIM_EGR_UG;     // latch PSC/ARR/CCR\n}\n\n// crude delay\nstatic void delay_ms(uint32_t ms) {\n    // ~4 cycles per loop at -O2 on Cortex-M4F; tweak if needed\n    // For simplicity, use a coarse busy wait:\n    volatile uint32_t n = ms * 16000UL; // assuming 64–80 MHz core; it's okay if approximate\n    while (n--) __NOP();\n}\n\nint main(void) {\n    // --- 1) Enable clocks ---\n    RCC-&gt;AHB2ENR  |= RCC_AHB2ENR_GPIOAEN;       // GPIOA clock\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;       // TIM2 clock\n\n    // --- 2) Configure PA0 as AF1 (TIM2_CH1) ---\n    // PA0: MODER=10 (AF), AFRL0=0001 (AF1), push-pull, high speed\n    GPIOA-&gt;MODER   = (GPIOA-&gt;MODER & ~(3U &lt;&lt; (0*2))) | (2U &lt;&lt; (0*2)); // AF\n    GPIOA-&gt;AFR[0]  = (GPIOA-&gt;AFR[0] & ~(0xFU &lt;&lt; (0*4))) | (1U &lt;&lt; (0*4)); // AF1\n    GPIOA-&gt;OSPEEDR |= (3U &lt;&lt; (0*2));   // high speed (optional)\n    GPIOA-&gt;OTYPER  &= ~(1U &lt;&lt; 0);      // push-pull\n    GPIOA-&gt;PUPDR   &= ~(3U &lt;&lt; (0*2));  // no pull (or set to taste)\n\n    // --- 3) Configure TIM2 base to 1 MHz tick ---\n    // PSC = TIM2CLK/TARGET_TICK - 1 -&gt; 80 MHz / 1 MHz - 1 = 79\n    TIM2-&gt;CR1   = 0;                   // upcount, edge-aligned\n    TIM2-&gt;PSC   = (TIM2CLK_HZ / TARGET_TICK) - 1U;\n    TIM2-&gt;ARR   = 999;                 // placeholder (1 kHz initially)\n    TIM2-&gt;CCR1  = 500;                 // 50% duty\n\n    // PWM mode 1 on CH1 + preload\n    // OC1M = 110 (bits 6:4), OC1PE=1 (bit 3)\n    TIM2-&gt;CCMR1 &= ~((7U &lt;&lt; 4) | (1U &lt;&lt; 3));\n    TIM2-&gt;CCMR1 |=  (6U &lt;&lt; 4) | (1U &lt;&lt; 3);\n\n    // Enable output on CH1 (active-high)\n    TIM2-&gt;CCER  &= ~((1U&lt;&lt;1) | (1U&lt;&lt;3)); // CC1P=0, CC1NP=0\n    TIM2-&gt;CCER  |=  (1U&lt;&lt;0);             // CC1E=1\n\n    // Enable ARR preload and latch settings\n    TIM2-&gt;CR1   |= TIM_CR1_ARPE;\n    TIM2-&gt;EGR    = TIM_EGR_UG;\n\n    // --- 4) Start timer ---\n    TIM2-&gt;CR1   |= TIM_CR1_CEN;\n\n    // --- Demo: cycle a few musical-ish tones ---\n    while (1) {\n        tim2_set_freq(220);  // A3\n        delay_ms(800);\n        tim2_set_freq(440);  // A4\n        delay_ms(800);\n        tim2_set_freq(880);  // A5\n        delay_ms(800);\n        tim2_set_freq(1000); // 1 kHz\n        delay_ms(800);\n    }\n}\nThe code provided seems resonable to me. It configures TIM2 for PWM generation, same way I could have done with TIM15. It calls the necessary structures such as CR1, CCR, PSC, and ARR. The code compiles of course except for some specific variables the LLM probably defined in the assumed stm32l4xx.h header file. I didn’t test the code on hardware, but from what I analyzed so far I believe it works well. The LLM also uses the crude delay with the assembly __nop function."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab the FPGA was used to drive a Dual 7-segment display with the goal to demonstrate time multiplexing and how to efficiently use the I/O on our FPGA."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab the FPGA was used to drive a Dual 7-segment display with the goal to demonstrate time multiplexing and how to efficiently use the I/O on our FPGA."
  },
  {
    "objectID": "labs/lab2/lab2.html#experiment-setup-and-design-overview",
    "href": "labs/lab2/lab2.html#experiment-setup-and-design-overview",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display",
    "section": "Experiment Setup and Design Overview",
    "text": "Experiment Setup and Design Overview\nThe main task for the lab was to control the provided HDSP-521A dual 7-Segment display using only 7 pins from our FPGA. The FPGA received two different switch inputs from two different switch blocks, each meant to drive a specific 7-segment display. With limited hardware, the dual 7-segment pins had to share FPGA pins to drive the respective segment displaying the hex equivalent of the switch binary input. The FPGA outputted enablers meant to choose which display has to turn on by driving the respective common anodes HIGH. Each display responded to a respective switch block. Two 2N3906 PNP transistors were used to help drive large currents to the common anodes so as to avoid excessive current draw from the FPGA. An extra task was to show the sum of the two displayed digits using LEDs. These LEDs were also driven by the I/O pins from the FPGA.\n\nTime-multiplexing Logic\nTurning on 2 displays that share pins meant that we had to switch so fast that the two displays appear as if they are on at the same time wihout any flickering observed between them. To do this time multiplexing was used. Time multiplexing is a method in digital logic where different elements share common hardware resources for different purposes at different times. We had to implement a timing logic to achieve this task.\nThe human eye can detect flickering up to \\(\\sim60 Hz\\) (around \\(16.67 ms\\) per cycle). With two digits, this would mean that each must be active for at least 120 switches per second (60Hz * 2). To ensure “no flickering” switching between the two displays had to be every \\(\\sim8.3 ms\\) or less. I opted to switch at every \\(\\sim2 ms\\) which gives a \\(\\sim240 Hz\\) refresh rate (switching every \\(1*10^5\\) ticks), which is too fast for the human eye to detect. The module doing the switching leveraged the on-board high-speed oscillator as a clock frequency and used it to implement a counter that switched at the specified times. Another additional procedure to ensure no bleeding happens, all the displays were turned off for a brief time (500 clock cycles) to ensure there is no overlap by letting the transistors fully turn off. During the cooldown, the correct digit is loaded onto sevenSegIn, the display input, which is sent immediately when the counter completes and the dedicated segment turns on.\n\n\nDisplay and LED Control Logic\nAfter evey switching a specific display anode high using a 2-bit signal, onSeg[1:0], where MSB showed the state of the left display and LSB, the right display. This signal was multiplexed and used to select which switch input to send to the display that was activated. The left display was controlled by the on-board DIP switch module (sW1[3:0]), while the right one was controlled by the DIP switch component on the breadboard (sW2[3:0]). The selected input was sent to the dual 7-segment display to display the respective digit using the combinational logic module designed in LAB1.\nThe sum of the displayed numbers was calculated by simply performing binary addition of the two 4-bit switch inputs producing a 5-bit output. Each bit of the sum was relayed to a specific LED, giving us 5 different LEDs to show the binary representation of the sum. The modules to control these elements were written in SystemVerilog to run on the FPGA and to ensure proper communication and signal control, they all followed the hierachy in the block diagram below:\n\n\n\nFigure 1: Hierachical Block Diagram\n\n\nAfter running the simulation ensuring modules work as expected, the full setup was installed on a breadboard to control the dual 7-segment display and sum LEDs using the following schematic:\n\n\n\nFigure 2: FPGA Experiment Wiring Setup\n\n\nAs seen from the schematic, the sum LEDs are hooked up to \\(100\\Omega\\) resistors and the 7-segment display to \\(200\\Omega\\) resistors to ensure reasonable (safe) current draw from the FPGA.\nThe 7-segment display LEDs have a typical forward voltage drop of \\(\\approx1.70V\\). The target current draw per segment was \\(8mA\\) and the input voltage of \\(3.3V\\) from the FPGA, I calculated the desired resistor values using \\(R = \\frac{V_{\\text{in}} - V_{f}}{I_{des}}\\) obtaining that R should be \\(\\sim200\\Omega\\) where worst case scenario with all 14 segments on, the total load current is \\(112mA\\), much below FPGA rated max. Similar calculation was used for transistors with \\(V_{CE}\\approx0.7V\\) and a target \\(I_{BC}\\approx8mA\\), and the red sum LEDs with \\(V_F=1.80\\) and target current around \\(15mA\\). This gives \\(\\sim330\\Omega\\) and \\(100\\Omega\\) for the transistors and sum LEDs respectively."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench simulation\nSetting up the simulation was challenging due to the fact that the time multiplexing counter went on for too many cycles that the assert statements would finish before any switching was done making it hard to test the time multiplexing logic.\nMy first attempt was to create a fast clock so that counting happens so fast and could see switching. I adjusted my timescale to `timescale 1ns/1ps allowing me to create a clock with period of \\(0.2ns\\) (\\(50GHz\\)). This didn’t work as good because the simulation had to run for as long as \\(200ms\\) just to see a switch cycle. My final solution was to implemenet a parameter SWITCH_COUNT which allowed me to control the number of ticks outside the ledControl module. In my testbench I set SWITCH_COUNT = 1 which essentially switched enablers after 1 tick, equivalent to switching every clock cycle which solved my issue. Each module was simulated individually and running the simulation yielded the following waves:\n\n\n\nFigure 3: QuestaSim Screenshot Showing Time Multiplexing and LED Sum Simulation Outputs\n\n\n\n\n\nFigure 4: QuestaSim Screenshot Showing Waves For All 256 Possible Cases\n\n\nThe waves in Figure 3 above show that the the two displays turn on at different times as onSeg[1] and onSeg[1] oscillate oppositely. The waves shows that sevenSegIn chooses sW1 switch input when onSeg[1] is HIGH and sW2 input when switch onSeg[0] is HIGH showing the time multiplexing logic works. The LED sum also worked properly and was verified using the assert statement, executing all with no error returned.\n\n\n\nFigure 4: QuestaSim Screenshot Showing Seven-segment Display Simulation Outputs and Expected Outputs\n\n\nThe seven segment display also resopnds as expected.\n\n\nHardware Testing\nAll components were collected and assembled on an extended breadboard following the schematic in Figure 2. Using Radiant programmer, the code was uploaded to the FPGA to test the time multiplexing logic, the sum LEDs, and the 7-segment display. The hardware responded properly as shown in the example video below:\n\n\nVideo\nFigure 6: Hardware Execution Example Showing Outputs to Different Switch Inputs"
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nThis lab took around 25 hours to complete mainly because I had to go through a lot of debugging processes to fix and setup my testbench to properly illustrate time multiplexing. I solved the issue by learning how to deal with timing and synchronization issues and implementing a solution to modify the counter divider in my testbench. Another major issue was bleeding between the two displays which was caused by faulty adapter and FPGA pins probably damaged or due to poor soldering. I had to resolder most of them as a temporary fix but will look deeper into the issue as the bleeding is at its lowest but not completely gone. The lab was amazing overall and I learnt about time-multiplexing, a skill I believe will be useful in the future labs and projects of this class."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "E155 Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nI used Chatgpt 5 to run the prompt and it gave me the code below. The code was good except that syntheis didn’t work as the LLM was running a line `default_nettype none meant to set the global net parameter to none until all net parameters are specifically defined. Radiant wasn’t happy with that and as usual the LLM faught until it accepted that the best solution is to remove the line producing the next code that synthesized:\n//==============================================================\n// Hex -&gt; 7-seg decoder, common-anode, segments gfedcba (active-low)\n//==============================================================\nmodule seg7_decoder_ca (\n  input  logic [3:0] hex,\n  output logic [6:0] seg_n       // g f e d c b a, active-low\n);\n  always_comb begin\n    unique case (hex)\n      4'h0: seg_n = 7'b1000000; // 0\n      4'h1: seg_n = 7'b1111001; // 1\n      4'h2: seg_n = 7'b0100100; // 2\n      4'h3: seg_n = 7'b0110000; // 3\n      4'h4: seg_n = 7'b0011001; // 4\n      4'h5: seg_n = 7'b0010010; // 5\n      4'h6: seg_n = 7'b0000010; // 6\n      4'h7: seg_n = 7'b1111000; // 7\n      4'h8: seg_n = 7'b0000000; // 8\n      4'h9: seg_n = 7'b0010000; // 9\n      4'hA: seg_n = 7'b0001000; // A\n      4'hB: seg_n = 7'b0000011; // b\n      4'hC: seg_n = 7'b1000110; // C\n      4'hD: seg_n = 7'b0100001; // d\n      4'hE: seg_n = 7'b0000110; // E\n      4'hF: seg_n = 7'b0001110; // F\n      default: seg_n = 7'b1111111; // all off\n    endcase\n  end\nendmodule\n\n//==============================================================\n// Time-multiplex two digits using a single decoder.\n// - Common-anode digits, segments active-low (gfedcba).\n// - seg0_n drives left digit's 7 segment pins, seg1_n right's.\n// - digit_en_n are optional digit enables (active-low).\n// - Short blanking reduces ghosting when switching digits.\n//==============================================================\nmodule sevenseg_timemux2 #(\n  parameter int unsigned CLK_HZ      = 12_000_000, // FPGA clock (Hz)\n  parameter int unsigned FRAME_HZ    = 1000,       // full frames per second\n  parameter int unsigned BLANK_TICKS = 4           // blanking clocks per switch\n)(\n  input  logic        clk,\n  input  logic        reset,       // synchronous, active-high\n  input  logic [3:0]  hex0,        // left digit value\n  input  logic [3:0]  hex1,        // right digit value\n  output logic [6:0]  seg0_n,      // left  digit segments (gfedcba, active-low)\n  output logic [6:0]  seg1_n,      // right digit segments (gfedcba, active-low)\n  output logic [1:0]  digit_en_n   // {left,right} enables, active-low\n);\n\n  // ---- timing math (guard against tiny clocks/params) ----\n  localparam int unsigned HALF_FRAME_TICKS_RAW = (CLK_HZ / (2*FRAME_HZ));\n  localparam int unsigned HALF_FRAME_TICKS     = (HALF_FRAME_TICKS_RAW == 0) ? 1 : HALF_FRAME_TICKS_RAW;\n  localparam int unsigned SHOW_TICKS_RAW       = (HALF_FRAME_TICKS &gt; BLANK_TICKS) ? (HALF_FRAME_TICKS - BLANK_TICKS) : 1;\n  localparam int unsigned SHOW_TICKS           = (SHOW_TICKS_RAW == 0) ? 1 : SHOW_TICKS_RAW;\n\n  // Width for tick counter (&gt;=1)\n  localparam int unsigned TICK_W = (HALF_FRAME_TICKS &lt;= 1) ? 1 : $clog2(HALF_FRAME_TICKS);\n\n  typedef enum logic [1:0] {SHOW0, BLANK0, SHOW1, BLANK1} state_e;\n\n  state_e                 state, state_n;\n  logic [TICK_W-1:0]      tick,  tick_n;\n  logic [3:0]             mux_hex;\n  logic [6:0]             dec_seg_n;\n\n  // One shared decoder\n  seg7_decoder_ca u_dec (\n    .hex   (mux_hex),\n    .seg_n (dec_seg_n)\n  );\n\n  // Next-state / timer\n  always_comb begin\n    state_n = state;\n    tick_n  = tick + logic'(1);\n\n    unique case (state)\n      SHOW0:  if (tick == logic'(SHOW_TICKS - 1))  begin state_n = BLANK0; tick_n = '0; end\n      BLANK0: if (tick == logic'(BLANK_TICKS - 1)) begin state_n = SHOW1;  tick_n = '0; end\n      SHOW1:  if (tick == logic'(SHOW_TICKS - 1))  begin state_n = BLANK1; tick_n = '0; end\n      BLANK1: if (tick == logic'(BLANK_TICKS - 1)) begin state_n = SHOW0;  tick_n = '0; end\n      default: begin state_n = SHOW0; tick_n = '0; end\n    endcase\n  end\n\n  // State and counter registers\n  always_ff @(posedge clk) begin\n    if (reset) begin\n      state &lt;= SHOW0;\n      tick  &lt;= '0;\n    end else begin\n      state &lt;= state_n;\n      tick  &lt;= tick_n;\n    end\n  end\n\n  // Which nibble goes into the decoder?\n  always_comb begin\n    unique case (state)\n      SHOW0, BLANK0: mux_hex = hex0;\n      default      : mux_hex = hex1;\n    endcase\n  end\n\n  // Output driving with blanking\n  localparam logic [6:0] OFF = 7'b1111111; // all off (active-low)\n\n  always_comb begin\n    // defaults: blanked\n    seg0_n     = OFF;\n    seg1_n     = OFF;\n    digit_en_n = 2'b11; // both disabled (active-low)\n\n    unique case (state)\n      SHOW0: begin\n        seg0_n     = dec_seg_n;\n        digit_en_n = 2'b01; // left enabled (active-low), right disabled\n      end\n      SHOW1: begin\n        seg1_n     = dec_seg_n;\n        digit_en_n = 2'b10; // right enabled, left disabled\n      end\n      default: begin\n        // BLANK0 / BLANK1: keep both off\n        seg0_n     = OFF;\n        seg1_n     = OFF;\n        digit_en_n = 2'b11;\n      end\n    endcase\n  end\n\nendmodule\nThesecond prompt worked properly. I received two different files: one top module that istantiates the Lattice iCE40 high-freq oscillator and feeds the mux core, and a second module sevenSegTimeMux. It is a reusable core that takes a clock, two 4-bit values, and uses one sevenSegDispCtrl instance to alternately decode and latch the outputs into two 7-bit buses. This failed to synthesize because of the use of SB_HFOSC module siimilar to last week. To fix it, I had to specifically tell it to use HSOSC hf_osc as demosntrated in my files. However there was another issue where it was calling clk in the code but it didn’t instantiate the variable/logic. When I complained about the error, it would just suggest fixex not in the code the LLM gave me but in the files that I shared. I would have to specifically compalain about it’s code for changes, but still no changes but instead broken recommendations meant to “fix my code.” However, having done the AI Prototype summary earlier, I learned the trick of creating a forced off period while multiplexing the displays."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi! I’m Josaphat Ngoga, a senior Engineering major at Harvey Mudd College. My interests span both Mechanical and Electrical engineering, with a focus on mechanical design, electronics, and hardware systems. I enjoy working on projects that bring these areas together—especially those involving FPGA development and microcontroller-based applications. You can find more about my interests, skills, and projects at jngoga.vercel.app"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "The Modern Brains\n\n\nA journey to The Depths of Machine Psychology\n\n\n\n\n\nAug 29, 2025\n\n\nJosaphat Ngoga\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "finalProject/proposal.html",
    "href": "finalProject/proposal.html",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "",
    "text": "The goal of the project is to demonstrate serial data transfer through a mechanical actuation mechanism rather than traditional electrical signaling. Mechanical motion, driven by solenoids, relays, and limit switches, replaces voltage as the medium for communication across nine parallel channels, with one serving as the CLK for synchronization and eight for data bits, transmitting one byte per cycle in simplex mode. Each relay energizes a solenoid when its input is HIGH, pressing a limit switch on the receiver side to register a HIGH signal. For secure communication, the sender encrypts messages using AES-128, and the receiver decrypts the transmitted bytes to reconstruct the plaintext. Communication between sender and receiver is coordinated through a web app: the user types or uploads a message, where the ESP8266/ESP32 sends/receives a request to/from the MCU–FPGA system for encryption, transmission, decryption, and final display of the recovered message on the receiver’s web page."
  },
  {
    "objectID": "finalProject/proposal.html#introduction-and-project-overview",
    "href": "finalProject/proposal.html#introduction-and-project-overview",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "",
    "text": "The goal of the project is to demonstrate serial data transfer through a mechanical actuation mechanism rather than traditional electrical signaling. Mechanical motion, driven by solenoids, relays, and limit switches, replaces voltage as the medium for communication across nine parallel channels, with one serving as the CLK for synchronization and eight for data bits, transmitting one byte per cycle in simplex mode. Each relay energizes a solenoid when its input is HIGH, pressing a limit switch on the receiver side to register a HIGH signal. For secure communication, the sender encrypts messages using AES-128, and the receiver decrypts the transmitted bytes to reconstruct the plaintext. Communication between sender and receiver is coordinated through a web app: the user types or uploads a message, where the ESP8266/ESP32 sends/receives a request to/from the MCU–FPGA system for encryption, transmission, decryption, and final display of the recovered message on the receiver’s web page."
  },
  {
    "objectID": "finalProject/proposal.html#fpga-use",
    "href": "finalProject/proposal.html#fpga-use",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "FPGA Use",
    "text": "FPGA Use\nThe project uses two FPGAs, one on each side of the communication system. Each FPGA handles AES-128 encryption and decryption while interfacing directly with the mechanical bus. The sender FPGA receives plaintext and encryption key from the MCU, encrypts it, and performs bit-banging to maintain synchronization and ensure that a complete byte is transmitted every cycle. The receiver FPGA reads each incoming byte, decrypts it, and sends the plaintext to the MCU for display. It also manages switch input synchronization through debouncing to ensure clean and reliable signal detection. The new FPGA functions are highlighted below:\n\nAES-128 decryption according to the NIST FIPS 197 standard\nBit-banging/hardware synchronization\ndata transfer indicators (Mainly LEDs showing channel status, i.e, HIGH/LOW)\n\nThe FPGAs communicate with the MCUs through SPI and interface with the mechanical bus using a custom serial bit driver that handles all data transmission and input reception. The transfer rate of the bits will be set depending on how we synchonize the receiving end. Bit transfer is handled by the clock, and we can change the clock speed to achieve synchronization, and this will in turn affect how fast we can send bits across.\n\nFPGA Resource Usage\nThe FPGAs in this setup will perform AES-128 encryption and decryption, both of which rely heavily on combinational logic, resulting in high LUT usage. Most of the resources are consumed by the iterative round operations, key expansion, and storing S-box substitution tables, with additional LUTs used by the FSMs that will control the actuators and debounce switch inputs. The UPduino has built-in macros for SPI, but serial communication can also use some resources. From research on the implementation of these functions, we estimated a total of ~3500 LUTs. Since each UPDuino (iCE40UP5K) provides 5,280 logic cells, this remains within a safe utilization range. For on-board storage, only about 5 kB of the available 128 kB memory is required for S-box tables and related data. The tasks stated above are split between 2 FPGAs, therefore, we stay even further from the resource limits of the boards."
  },
  {
    "objectID": "finalProject/proposal.html#mcu-use",
    "href": "finalProject/proposal.html#mcu-use",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "MCU Use",
    "text": "MCU Use\nThe project uses two MCUs, one for each side of the system. They serve as the main interface for web communication and text encoding, converting messages into byte data that the FPGA can process. MCUs are ideal for this role due to their large on-board memory, which allows them to handle larger text data. Each MCU also participates in the encryption and decryption process, managing the exchange of keys and ciphertext/plaintext with the FPGAs. Additionally, the MCUs will control all system indicators and feedback mechanisms that help monitor the efficiency of the system. The new MCU functions are shown below:\n\nASCII encoding/decoding\nFeedback & Monitoring:\n\nValidate if data received matches the intended message (transferred message)\nTrack clock (clk) speed as well as data transfer speed.\nDetermine progress of data transfer\n\nFault report and handling:\n\nstop transfer and report when received data ≠ sent data\nSystem kill switch (master stop)"
  },
  {
    "objectID": "finalProject/proposal.html#bill-of-materials",
    "href": "finalProject/proposal.html#bill-of-materials",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "Bill of Materials",
    "text": "Bill of Materials\n\nBOM for Final Project\n\n\nPart Name\nPart Number\nQuantity\nVendor\nPrice\nLink\n\n\n\n\n12V Relay Module\nSRD-12VDC-SL-C\n10\nAEDIKO\n13.16\nLink\n\n\n12V Solenoid\nZ24G50031OJX\n9\nTEHAUX\n36.54\nLink\n\n\nRoller Lever Arm Micro Limit Switch\nKW12-3\n10\nHiLetgo\n6.57\nLink\n\n\nFPGA\nUpduino v3.1\n2\nUpduino\nStockroom\nN/A\n\n\nMCU\nSTM32L432KC\n2\nSTM\nStockroom\nN/A\n\n\nMetal Rods\nN/A\n9\nN/A\nStockroom\nN/A\n\n\nESP8266\nESP-WROOM-02\n2\nEdwin Robotics\nStockroom\nN/A\n\n\nTotal\n\n\n\n$56.27"
  },
  {
    "objectID": "finalProject/proposal.html#project-performance-specs",
    "href": "finalProject/proposal.html#project-performance-specs",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "Project Performance Specs",
    "text": "Project Performance Specs\nWe expect the toughest stage to be the mechanical bus. Synchronizing all actuators and making sure that the receiver samples at the correct time will be the biggest challenge. Since the clock is also mechanical, the whole system is susceptible to any faults from that channel. Below are the main performance specs and secondary specs to check-off to verify the process and completeness of the project:\n\nMain performance spec:\n\nSend 16 characters/letters maximum\n[ ]\n\nSecondary performace specs:\n\nText messages are correctly sent/received between the ESP8266 to the MCU\nMCU correctly encodes & decodes the received word in ASCII\nMCU-FPGA encryption/decryption modules communicate and perform as expected\n9 mechanical channels properly synchronized between the two sides.\nStatus and progress LEDs respond as expected\nSystem stops immediately if received data is different from sent data.\nAll 8 data buses are read synchronously\nAble to receive & display at least 3 letters in a second i.e minimum 24bps transfer speed\n\n\nStrech performance specs:\n\nAble to send multiple words over\nAble to send words from a .txt file uploaded from the web app\nFaster transfer speeds (around 8 letters in a second, 64bps)\nEmoji handling"
  },
  {
    "objectID": "finalProject/proposal.html#project-timeline-task-allocation",
    "href": "finalProject/proposal.html#project-timeline-task-allocation",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "Project Timeline & Task Allocation",
    "text": "Project Timeline & Task Allocation\n\nBy 10/26/2025: Have the proposal and project approved and verified to begin working (Both).\nWeek of 10/27/2025: Submit purchase order. Develop and test MCU-FPGA encryption module (Josaphat) and MCU driver for ASCII encoding/decoding and web requests (Chistian).\nWeek of 11/03/2025: Machine and cutdown metal rods. Start assembling and testing the electronics and mechanical system. Troubleshoot annd resolve any issues errors (Both).\nWeek of 11/10/2025: Develop and test MCU-FPGA decryption module (Josaphat) and MCU code for system monitoring and fault detection (Christian).\nWeek of 11/17/2025: Preliminary testing of the full system. Connecting all parts and running all systems to check performance and troubleshoot errors (Both).\nWeek of 11/24/2025: Begin preliminary project report. Debug if any errors are still ongoing. If complete, look at implementing some strech goals or aesthetic modificatons. (Both)\nWeek of 12/01/2025: Finalize report. Perfom final system shakedown to validate all performance specs and prepare checkoff sheet. PROJECT DEMO!!! (Both)"
  },
  {
    "objectID": "finalProject/proposal.html#appendix",
    "href": "finalProject/proposal.html#appendix",
    "title": "MechaCrypt: A Solenoid-Based Encrypted Data Transmission System",
    "section": "Appendix",
    "text": "Appendix\nThe appendix contains images and diagrams highlighing the full setup and other considerations to ensure the project goes as planned:\nAll the relevant elements defined in the description above and will be connected together following the communication protocols and setup in Figure 1 below:\n\n\n\n\n\n\nFigure 1: Main Block Diagram.\n\n\n\nThe actuation block requires different modules and setup necessary for it to work as expected. The relay module specifications show the mentioned NO and NC connection modes. Figure 2 below shows the signals as well as voltage and circuit configurations:\n\n\n\n\n\n\nFigure 2: Hardware Actuation Block Diagram\n\n\n\n\n\n\n\n\n\nFigure 3: Hardware Actuation 3D Visualization\n\n\n\nThe team has a fall-back plan in case new errors and challenges come up along the way to ensure that at least the main idea of transfering encrypted data mechanically still stands.\n\n\n\n\n\n\nFigure 4: Fallback Plan"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, an FPGA and MCU were installed on a development board setup and tested to verify proper functionality. The FPGA was later programmed to control a 7-segment display and a couple on-board LEDs based on a series of DIP switches. First, the development board was built by soldering on each individual components following BOM, schematic, and the silkscreen on the provided PCB."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, an FPGA and MCU were installed on a development board setup and tested to verify proper functionality. The FPGA was later programmed to control a 7-segment display and a couple on-board LEDs based on a series of DIP switches. First, the development board was built by soldering on each individual components following BOM, schematic, and the silkscreen on the provided PCB."
  },
  {
    "objectID": "labs/lab1/lab1.html#development-board-setup",
    "href": "labs/lab1/lab1.html#development-board-setup",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "Development Board Setup",
    "text": "Development Board Setup\nThe primary purpose of this lab was to assemble the development board to be used for the different labs and projects over the semester. The provided board was an empty PCB to be populated by different electrical components within the categories of Through Hole Technology (THT) as Surface Mount Technology (SMT). The electrical components provided were: resistors, capacitors, voltage regulator, DIP switches, push-button switches, jumpers, and LEDs. At the heart of the board there is the Nucleo-L432KC microcontroller unit (MCU) and the UPduino v3.1 FPGA which is the primary component handling the tasks of this lab.\nThe soldering process was straightforward except for the SMT components. It was hard to solder the voltage regulators because the underside plate was not sticking to the board fully. Surprisingly it was easy to solder the LEDs and other smaller SMT components probaly because I was just connecting to specific terminals as opposed to the wide plate of the voltage regulators. Due to inventory shortages, I was unable to install D1, the LED responsible to show if the board is powered on. The complete development board is shown below:\n\n\n\nFigure 1: Fully Assembled Development Board"
  },
  {
    "objectID": "labs/lab1/lab1.html#experiment-setup",
    "href": "labs/lab1/lab1.html#experiment-setup",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "Experiment Setup",
    "text": "Experiment Setup\nThe main task of the lab was to light up on-board LEDs and a HDSP-511A seven-segment display using one of the DIP switch modules on the development board. This was to be done using SystemVerilog modules uploaded to the FPGA module on the board.\n\nFPGA and MCU Testing\nBefore setting up for the actual experiment the FPGA and MCU, the brains of the whole board, were tested to ensure they work and can communicate to the respective components on the board they’re internally connected to. Determining if the board was powered on properly required some work without the red on-board VIN LED but I was able to read the input voltages from the regulators and the VIN pins using the tabletop multimeters in the lab space.\nUsing Lattice Radiant to program and upload the code to the FPGA, an onboard LED (D3) was toggled to blink at about 1HZ. Testing the MCU used a similar approach but Segger Embedded Studio was used to program the MCU where it blinked three on-board LEDs (D2, D3, and D7). These testing procedures worked out as expected indicating that the FPGA and MCU are integrated to the board correcltly.\n\n\nFPGA Experiment Design\nTo further test the board we had to drive two LEDs responding to the states of the four-DIP switch module. Based on the provided truth table, the first LED had to react to the first 2 DIP switches in a manner resembling an exclusive OR (XOR) gate. The second LED had to react to the last pair of DIP switches similar to an AND gate. These LEDs responded to their respective switch pair regardless of the other pair. The third LED to be controlled had to blink at about 2.4 Hz. This was done by leveraging the HSOSC module of the iCE40 Technology Library in Lattice Radiant. This allowed access to the on-board high speed oscillator providing 48MHz. Each cycle of third LED would last around 0.417 seconds meaning a full cycle requires around \\(\\approx2*10^7\\) ticks every second. With a 50% duty cycle it would take \\(10^7\\) ticks for the half cycle. This logic was used to design a flip flop that switched the state of the LED every \\(10^7\\) ticks (everytime the logic counter hit 10,000,000).\nThe second task was to setup a 7-segment display to display a single hexadecimal digit specified the binary state of the 4 DIP switches (shown as swDIP [3:0] in the code). The segments of the display share a common anode that is to be powered by 3.3V from the FPGA. Therefore to turn on the segments, a logic 0 was applied to the segment cathode line. Since we have a 4-bit switch state, it meant we could display all hex digits from 0x0 to 0xF. The modules to control these elements were written in SystemVerilog to run on the FPGA and to ensure proper communication and signal control, they all followed the hierachy in the block diagram below:\n\n\n\nFigure 2: Hierachical Block Diagram\n\n\nAfter running the simulation, the full setup was installed on a breadboard to visualize the actions of the on-board LEDs and to control the 7-segment display using the following schematic:\n\n\n\nFigure 3: FPGA Experiment Wiring Setup\n\n\nAs seen from the schematic, the on-board LEDs are hooked up to \\(1k\\Omega\\) resistors and the 7-segment display to \\(100\\Omega\\) resistors to ensure reasonable (safe) current draw from the FPGA.\nThe 7-segment display LEDs have a typical forward voltage drop of \\(\\approx2.00V\\). The FPGA limits the total current draw to \\(200mA\\). With a target current between \\(2-20mA\\) to drive the LEDs, and the input voltage of \\(3.3V\\) from the FPGA, I calculated the desired resistor values using \\(R = \\frac{V_{\\text{in}} - V_{f}}{I_{des}}\\) obtaining that R should be between \\(65-650\\Omega\\). I opted for the modest \\(100\\Omega\\) which draws \\(13mA\\) and is well within a range where the total current draw of the full display won’t overwhelm the FPGA."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench simulation\nSetting up the simulation was challenging due to different hurdles presented by Lattice Radiant, for example the tendency to sysnthesize the .tv file even though it’s not Verilog. The testbench also required a “timeprecision specification” which was fixed by adding the code `timescale 1ns/1ns to the top of the testbench code. Each module was simulated individually and running the simulation yielded the following waves:\n\n\n\nFigure 4: QuestaSim Screenshot Showing on-board LED Simulation Outputs and Expected Outputs\n\n\n\n\n\nFigure 5: QuestaSim Screenshot Showing Seven-segment Display Simulation Outputs and Expected Outputs\n\n\nAs shown from the simulation waves in Figures 4 and 5, the setup responded as expected which is a good sign.\n\n\nHardware Testing\nThe blinking LED could not be visualized using an automated testbench, Figure 6 below shows the oscilloscope trace indicating the LED is blinking at the desired \\(2.4Hz\\) and with a duty cycle of \\(50\\%\\).\n\n\n\nFigure 6: Oscilloscope Trace Showing Blinking LED\n\n\nUsing Radiant programmer, the code was uploaded to the FPGA to test the response of the on-board LEDs and the 7-segment display. The hardware responded properly as shown in the example figures below:\n\n\n\nFigure 7: Hardware Execution Example 1 Showing Outputs to Switch Input 4b’1101\n\n\n\n\n\nFigure 8: Hardware Execution Example 1 Showing Outputs to Switch Input 4b’1001"
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nThis lab took around 22 hours to complete mainly because I had to go through a lot of debugging processes to ensure my hardware works and connect to the board. In the end, it turned out to be the issue that I assigned hardware pin constraint to one of the SPI pins (Pin 12) which is used to connect to the FPGA. The lab was amazing overall and I was able to brush up my skills earned in E85."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nI used the new and updated LLM chatGPT 5.0 which is expected to be faster and smarter. After inputing the prompt, I received the following SystemVerilog code.\n// iCE40UP5K: Blink an LED at 2 Hz using the internal high-speed oscillator\n// Tooling: Yosys/nextpnr-ice40 or Radiant/Trellis\n`default_nettype none\n\nmodule top (\n    output logic LED   // constrain this to your chosen package pin in the .pcf/.lpf\n);\n    // ------------------------------------------------------------------------\n    // Internal high-speed oscillator (nominal 48 MHz with selectable dividers)\n    // CLKHF_DIV options (as strings):\n    //   \"0b00\" = 48 MHz, \"0b01\" = 24 MHz, \"0b10\" = 12 MHz, \"0b11\" = 6 MHz\n    // We'll use 12 MHz for a modest counter size.\n    // ------------------------------------------------------------------------\n    logic clk_hf;\n\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b10\")   // 12 MHz\n    ) u_hfosc (\n        .CLKHF   (clk_hf),\n        .CLKHFEN (1'b1),     // enable clock\n        .CLKHFPU (1'b1)      // power up\n    );\n\n    // ------------------------------------------------------------------------\n    // Blink at 2 Hz: toggle every half period (0.25 s)\n    // For a 12 MHz clock: cycles per toggle = 12_000_000 / (2*2) = 3_000_000\n    // ------------------------------------------------------------------------\n    localparam int unsigned CLOCK_HZ      = 12_000_000;\n    localparam int unsigned BLINK_HZ      = 2;\n    localparam int unsigned TOGGLE_CYCLES = CLOCK_HZ / (2 * BLINK_HZ);\n\n    // Counter width computed from the terminal count\n    localparam int unsigned CNT_W = (TOGGLE_CYCLES &gt; 1) ? $clog2(TOGGLE_CYCLES) : 1;\n\n    logic [CNT_W-1:0] cnt = '0;\n    logic             led_q = 1'b0;\n\n    always_ff @(posedge clk_hf) begin\n        if (cnt == TOGGLE_CYCLES-1) begin\n            cnt   &lt;= '0;\n            led_q &lt;= ~led_q;   // toggle LED every 0.25 s -&gt; 2 Hz blink\n        end else begin\n            cnt &lt;= cnt + 1'b1;\n        end\n    end\n\n    assign LED = led_q;\nendmodule\n\n`default_nettype wire\nThis code is well designed but it failed to synthesize because of the use of SB_HFOSC module. Radiant insisted it couldn’t find the module and the LLM kept on insisting I find it in my install files which I couldn’t. To fix it, I had to specifically tell it to use HSOSC hf_osc where the module synthesized properly.\n// Blink LED at 2 Hz using internal HSOSC (Radiant/LSE-friendly)\n`default_nettype none\n\nmodule top (\n    output logic LED\n);\n\n    // ------------------------------------------------------------------------\n    // HSOSC primitive (some Radiant/LSE setups expose this name).\n    // CLKHF_DIV: \"0b00\"=48 MHz, \"0b01\"=24 MHz, \"0b10\"=12 MHz, \"0b11\"=6 MHz\n    // ------------------------------------------------------------------------\n    localparam string DIV_SEL = \"0b10\"; // 12 MHz\n    logic clk_hf;\n\n    HSOSC hf_osc (\n        .CLKHF   (clk_hf),\n        .CLKHFEN (1'b1),\n        .CLKHFPU (1'b1)\n    );\n    defparam hf_osc.CLKHF_DIV = DIV_SEL;\n\n    // ------------------------------------------------------------------------\n    // 2 Hz blink (toggle every 0.25 s)\n    // ------------------------------------------------------------------------\n    localparam int unsigned CLOCK_HZ = (DIV_SEL==\"0b00\") ? 48_000_000 :\n                                       (DIV_SEL==\"0b01\") ? 24_000_000 :\n                                       (DIV_SEL==\"0b10\") ? 12_000_000 : 6_000_000;\n\n    localparam int unsigned BLINK_HZ      = 2;\n    localparam int unsigned TOGGLE_CYCLES = CLOCK_HZ / (2 * BLINK_HZ);\n    localparam int unsigned CNT_W         = (TOGGLE_CYCLES &gt; 1) ? $clog2(TOGGLE_CYCLES) : 1;\n\n    logic [CNT_W-1:0] cnt = '0;\n    logic             led_q = 1'b0;\n\n    always_ff @(posedge clk_hf) begin\n        if (cnt == TOGGLE_CYCLES-1) begin\n            cnt   &lt;= '0;\n            led_q &lt;= ~led_q;\n        end else begin\n            cnt &lt;= cnt + 1'b1;\n        end\n    end\n\n    assign LED = led_q;\nendmodule\n\n`default_nettype wire\nThe LLM used some new declarations that I didn’t understand so I had to ask it to explain more about them. For example the use of localparam ensures that the set variables stay within the module and can’t be altered by top level modules or other sub modules. Kinda like private in java. This also allowed the LLM to use numbers instead of writing every math in binary logic. The addition of `default_nettype wire ensures that SystemVerilog synthesis errors out when there is an undeclared identifier instead of declaring it as a wire which complicates the debugging process in case of an error. Next time I use an LLM I’d make sure to have a more specific prompt that specifies some things to use and other specifics to keep in mind."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "E155 Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab, the FPGA was used to read inputs from a 4x4 matrix keypad, and drive the decoded inputs on a dual 7-segment display. The main purpose of this lab was to learn how to deal with timing issues within logic when combining asynchronous and synchronous inputs and data. The lab also leveraged the time-multiplexing logic explored in last week’s lab."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "E155 Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab, the FPGA was used to read inputs from a 4x4 matrix keypad, and drive the decoded inputs on a dual 7-segment display. The main purpose of this lab was to learn how to deal with timing issues within logic when combining asynchronous and synchronous inputs and data. The lab also leveraged the time-multiplexing logic explored in last week’s lab."
  },
  {
    "objectID": "labs/lab3/lab3.html#experiment-setup-and-design-overview",
    "href": "labs/lab3/lab3.html#experiment-setup-and-design-overview",
    "title": "E155 Lab 3: Keypad Scanner",
    "section": "Experiment Setup and Design Overview",
    "text": "Experiment Setup and Design Overview\nThe FPGA received hexadecimal inputs from the keypad. The two last digits had to be displayed on the HDSP-521A dual 7-Segment display with the most recent entry appearing on the right display while the previous one shifts to the left display. The design had to follow a couple consntraits such as: the design should lock up current numbers when multiple buttons are pressed; only the first keypress should be registered, and most of all, there should be no switch bouncing. To implement this logic, I had to design a Finite State Machine (FSM) that handles detection and scanning of keypad inputs which are to be decoded and shown on the display.\n\nKeypad FSM Logic\nThe finite state machine read the input from the keypad scanner, which were logic highs from the respective column of the pressed button. The FSM would continuously power one row of the scanner at a time until a button was pressed, connecting a row to a column and powering one of the column bits. My logic utilized a mealy FSM featuring a total of 12 states with each of the 4 rows attributed to 3 individual states serving a specific purpose as shown below:\nThe FSM logic starts in 4 scan states: S0, S3, S6, or S9 each corresponding to one of the 4 rows. They allow the FSM to scan around by powering an individual row. The FSM maintains this cycle over and over until the system registers a key input. Once a key press is detected, the FSM jumps into the candidate states: S1, S4, S7, or S10 where the respective row of the keypress is held HIGH. Sampling occurs in these states where the FSM waits and see if a key is valid. In case the key is invalid, such as due to bouncing or not held long enough, the FSM jumps back to the next scanning state, looking back at all rows. If the key is indeed valid (satisfies the one-hot logic) the FSM will stay in this state up until debouncing is complete and then jump into the hold states: S2, S5, S6, or S11 and stays there until the key is released and goes back to scanning.\nThe mentioned one-hot logic is to ensure that inputs are only recorded if a single column is pressed. This was achieved by using a bit manipulation trick outlined as (col != 4'b0000) && ((col & (col - 1)) == 4'b0000);. The value (col != 4'b0000) detects if at least one column is HIGH. The additional expression (col & (col - 1)) is always equal to 0 if the binary number is a power of 2 which is only possible if only one bit of the binary number is HIGH. Therefore combining the logic translates to: “TRUE if any column is HIGH and it’s only one column”. This logic helps lock the keypad by keeping the current numbers if more buttons at once therefore satisfying major constraints to successfuly complete this lab.\n\n\nSynchronization and Switch Debouncing\nThe keypad uses mechanical switches which means any input to the FPGA will be asynchronous. Before any modules depending on the input received the value of active columns, the asynchronous column input had to go through a synchronizer module that lined it up properly with the rising clock edge. This meant that every dependent module was delayed by one clock cycle but received a synchronized column input. This was particularly essenstial to ensure proper operation of the keypad scanning logic. The second phase of synchronization involved slowing down the rate of state transition. The clock extracted from the HSOSC hf_osc module is 48MHz. At this rate switch bounces are magnified in the system and will be seen as a flurry of press/release events which would be wrong. Also the electrical signal from the keypad doesn’t settle instantly and a fast clock would sample the column input before it stabilizes. To solve this, the code implements a clock divider that slows the scan rate down to \\(480Hz\\) (noted as clk_en in code) which is slow enough to allow inputs to settle, but also not too slow to risk delayed sampling of inputs. Also the slow clock enabled implementation of an easier debouncing logic. Using an oscilloscope, I observed traces of keypresses on the different keypads provided and I received overall a miimum bouncing of \\(\\sim4ms\\) and a maximum bouncing of \\(\\sim38ms\\). In my logic I opted to debounce to ensure I’m safe up to a \\(50ms\\) which compared to the measured data, offers me a safe zone off the maximum bouncing observed. I implemented another counter, DBcounter to count for cycles ensuring a 50ms debounce. Given the clk frequency and the desired debouncing window, I calculated \\(DBcounter = \\frac{50ms*480Hz}{1000}\\) giving me \\(24\\) ticks. These ticks determined how long the FSM held in the candidate states so that a key can be validated ensuring proper debouncing and sent into the hold states where it remains active until released.\nOverall, my FSM transition logic relied on three major signals which were keyPress determining if a single column is active and DBcounter which is the debounce counter for the current press and DEBOUNCE which sets the threshold cycles for a valid key press. Detailed transitions are shown in the diagram below:\n\n\n\nFigure 1: FSM State Transition Diagram\n\n\nAs shown in the Figure 1 above, given the specified signals, transition and cycling between the 12 states followed the following logic:\n\n\n\nTable 1: Next-state Logic for Keypad FSM\n\n\n\n\n\n\n\n\n\n\n\nCurrent State\nCondition\nNext State\nNotes\n\n\n\n\nS0\nkeyPress\nS1\nStart debounce on row[0]\n\n\n\n!keyPress\nS3\nAdvance to next row (row[1])\n\n\nS1\n!keyPress\nS3\nKey released → move to next row\n\n\n\nkeyPress && (DBcounter &lt; DEBOUNCE)\nS1\nKeep debouncing row[0]\n\n\n\nkeyPress && (DBcounter &gt;= DEBOUNCE)\nS2\nDebounce passed (row[0] confirmed)\n\n\nS2\nkeyPress\nS2\nHold while key remains pressed\n\n\n\n!keyPress\nS3\nRelease → advance to next row\n\n\nS3\nkeyPress\nS4\nStart debounce on row[1]\n\n\n\n!keyPress\nS6\nAdvance to next row (row[2])\n\n\nS4\n!keyPress\nS6\nKey released → move to next row\n\n\n\nkeyPress && (DBcounter &lt; DEBOUNCE)\nS4\nKeep debouncing row[1]\n\n\n\nkeyPress && (DBcounter &gt;= DEBOUNCE)\nS5\nDebounce passed (row[1] confirmed)\n\n\nS5\nkeyPress\nS5\nHold while key remains pressed\n\n\n\n!keyPress\nS6\nRelease → advance to next row\n\n\nS6\nkeyPress\nS7\nStart debounce on row[2]\n\n\n\n!keyPress\nS9\nAdvance to next row (row[3])\n\n\nS7\n!keyPress\nS9\nKey released → move to next row\n\n\n\nkeyPress && (DBcounter &lt; DEBOUNCE)\nS7\nKeep debouncing row[2]\n\n\n\nkeyPress && (DBcounter &gt;= DEBOUNCE)\nS8\nDebounce passed (row[2] confirmed)\n\n\nS8\nkeyPress\nS8\nHold while key remains pressed\n\n\n\n!keyPress\nS9\nRelease → advance to next row\n\n\nS9\nkeyPress\nS10\nStart debounce on row[3]\n\n\n\n!keyPress\nS0\nWrap to row[0]\n\n\nS10\n!keyPress\nS0\nKey released → wrap to row[0]\n\n\n\nkeyPress && (DBcounter &lt; DEBOUNCE)\nS10\nKeep debouncing row[3]\n\n\n\nkeyPress && (DBcounter &gt;= DEBOUNCE)\nS11\nDebounce passed (row[3] confirmed)\n\n\nS11\nkeyPress\nS11\nHold while key remains pressed\n\n\n\n!keyPress\nS0\nRelease → wrap to row[0]\n\n\n(default)\n(any)\nS0\nSafe reset\n\n\n\n\n\n\nThe FSM module had three major outputs: row[3:0] containing the value of the pressed row which is held and sent into the decoder to find the corresponding key; rowScan[3:0] following the same logic for row[3:0] but is used by the FPGA to signal which row on the breadboard to power on for scanning or reading inputs; en which signals to the decoder that a keypress is comfirmed so it can proceed to display numbers. The row logic exists within specific state groups. The enabler logic exists only in the candidates ( S1, S4, S7, or S10) but is asserted only after debouncing in those states is complete. The added dependency on clk_en is to ensure the enable is asserted on the clock edge, synchronizing it to the rest of actvities and behaviour in the FSM.\n\n\n\nTable 2: Output logic for keypad FSM\n\n\n\n\n\n\n\n\n\n\nOutput Signal\nState Group / Expression\nBehavior\n\n\n\n\nrow[0]\nstate ∈ {S0, S1, S2}\nAsserted when FSM is scanning/reading row[0]\n\n\nrow[1]\nstate ∈ {S3, S4, S5}\nAsserted when FSM is scanning/reading row[1]\n\n\nrow[2]\nstate ∈ {S6, S7, S8}\nAsserted when FSM is scanning/reading row[2]\n\n\nrow[3]\nstate ∈ {S9, S10, S11}\nAsserted when FSM is scanning/reading row[3]\n\n\nrowScan[3:0]\nrow[3:0]\nActively drives the keypad row lines (one-hot)\n\n\nen\nstate ∈ {S1, S4, S7, 10}\nSingle-cycle enable pulse when a keypress is confirmed\n\n\n\n\n\n\n\n\nKey Decoding and Key Display Logic\nThe confirmed row, synchronized column, and the enable signal are received by the module keypadDecoder. The row-column sandwich is used to determine exactly which key was pressed. This module realigns the enable signal to the system clock producing a single-cycle pulse en_rise that detects the rising edge of the en signal. When the pulse hits, the module assigns the currently decoded key to sw1[3:0] and the previous value to sw2[3:0]. These two values are then sent to the time-multiplexing module, ledControl. The module maintains the logic and procedures similar to the one used in lab 2. The module will set HIGH the anode of the right display and send the value sw1[3:0] to be displayed and then does the same to the left display and send sw2[3:0]. This switching is done at \\(240Hz\\) which is sufficient enough for a person to not notice any flickering or bleeding between displays.\n\n\nDesign Implementation\nThe modules to enforce the keypad logic and those that control the respective circuit elements were written in SystemVerilog to run on the FPGA. To ensure proper communication and signal control, they all followed the hierachy in the block diagram below:\n\n\n\nFigure 2: Hierachical Block Diagram\n\n\nAfter running the simulation ensuring modules work as expected, the full setup was installed on a breadboard to read the 4x4 matrix keypad and control the dual 7-segment display using the following schematic:\n\n\n\nFigure 3: FPGA Experiment Wiring Setup\n\n\nAs seen from the schematic, the keypad columns are hooked up to \\(100k\\Omega\\) pulldown resistors and the 7-segment display to \\(200\\Omega\\) series resistors to ensure reasonable (safe) current draw from the FPGA.\nThe 7-segment display LEDs have a typical forward voltage drop of \\(\\approx1.70V\\). The target current draw per segment was \\(8mA\\) and the input voltage of \\(3.3V\\) from the FPGA. The 2N3906 transistors used have \\(V_{\\text{CESAT}}=0.2V\\). I calculated the desired resistor values using \\(R = \\frac{V_{\\text{in}} - V_{f} - V_{\\text{CESAT}}}{I_{des}}\\) obtaining that R should be at least \\(\\sim175\\Omega\\). I opted for \\(\\sim200\\Omega\\) which ensures a more safer margin in terms of current drawn from the FPGA. Similar calculation was used for transistors with \\(V_{BEON}\\approx0.85V\\) and a target \\(I_{BC}\\approx8mA\\) . This gives \\(\\sim306\\Omega\\) and I went for \\(330\\Omega\\) for the transistor base which also is larger than the recommended to ensure a safer margin."
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "E155 Lab 3: Keypad Scanner",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench simulation\nThe testbenches were extremely helpful, especially for this particular lab. They helped me through my synchronization logic as I tried to ensure that all my signals are at the same clock cycles. They also helped me know how my scanning FSM was moving aroung and I noticed some issues that my FSM would set HIGH all rows before confirming a key which would display all 4 numbers in the pressed column before finaly settling on the actual number I pressed. This is where I figured out the benefit of tightening my FSM transitioning logic which fixed this issue.\n\n\n\nFigure 4: QuestaSim Screenshot Showing Keypad Input Synchronization and Scanning\n\n\n\n\n\nFigure 5: QuestaSim Screenshot Showing Input Key Decoding\n\n\nThe waves in the figure above show that the decoder will properly find the corresponding key and will display the default 4'hF anytime an invalid input is received such as when more than one row/col are reported as HIGH.\n\n\n\nFigure 6: QuestaSim Screenshot Showing Time Multiplexing Simulation Outputs\n\n\nThe waves in Figure 8 above show that the the two displays turn on at different times as onSeg[1] and onSeg[1] oscillate oppositely. The waves shows that sevenSegIn chooses sW1 switch input when onSeg[1] is HIGH and sW2 input when switch onSeg[0] is HIGH showing the time multiplexing logic works.\n\n\n\nFigure 7: QuestaSim Screenshot Showing Seven-segment Display Simulation Outputs and Expected Outputs\n\n\nThe seven segment display also resopnds as expected.\n\n\nHardware Testing\nAll components were collected and assembled on an extended breadboard following the schematic in Figure 3. Using Radiant programmer, the code was uploaded to the FPGA to test the keypad responses, proper timing and synchronizatin, FSM logic, and the 7-segment display. The hardware responded properly as shown in the example video below:\n\n\nVideo\nFigure 8: Hardware Execution Example Showing Outputs to Different Keypad Presses"
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "E155 Lab 3: Keypad Scanner",
    "section": "Conclusion",
    "text": "Conclusion\nThis lab took around 28 hours to complete. A lot of time was lost in figuring out the proper keypad scanning logic. This included the FSM logic, transitions and different restrictions to ensure the experiment passes the given constraints. I lost a lot of time through synchronization and timing issues. This is where I would say that testebenches were helpful because they helped me see where my keys and signals were going wrong as I noticed scanning errors and things were delayed and received different clock cycles. To fix most of these errors I minimized my signals’ dependance on combinational logic. I made almost all signals sequential and limited combinational assignments to outputs of the modules only."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype-summary",
    "href": "labs/lab3/lab3.html#ai-prototype-summary",
    "title": "E155 Lab 3: Keypad Scanner",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe goal of this prototype is to explore how AI handles design modularity when implementing digital systems. I used Chatgpt 5 to run the different prompts and it gave me the results below.\n\nMonolithic Code Attempt\n//------------------------------------------------------------\n// iCE40 UP5K: 4x4 matrix keypad → dual 7-segment display\n// - HSOSC internal clock (wrapper): HSOSC hf_osc ( .CLKHF(clk) );\n// - Debounce-by-design: one key registered per full press/release\n// - Balanced, flicker-free 2-digit multiplexing\n//------------------------------------------------------------\n\n//============================================================\n// Tick generator: emits 1-cycle pulses (enables) at target rates\n//============================================================\nmodule tick_gen #(\n    parameter int unsigned CLK_HZ  = 24_000_000, // &lt;-- set to your HSOSC frequency\n    parameter int unsigned SCAN_HZ = 200,        // keypad scan cadence\n    parameter int unsigned MUX_HZ  = 2000        // display mux tick (≈2 kHz total)\n)(\n    input  logic clk,\n    input  logic rst_n,\n    output logic scan_tick,\n    output logic mux_tick\n);\n    localparam int unsigned SCAN_DIV = (CLK_HZ/SCAN_HZ);\n    localparam int unsigned MUX_DIV  = (CLK_HZ/MUX_HZ);\n\n    logic [$clog2(SCAN_DIV)-1:0] scan_cnt;\n    logic [$clog2(MUX_DIV)-1:0 ] mux_cnt;\n\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            scan_cnt  &lt;= '0;\n            mux_cnt   &lt;= '0;\n            scan_tick &lt;= 1'b0;\n            mux_tick  &lt;= 1'b0;\n        end else begin\n            // scan tick\n            if (scan_cnt == SCAN_DIV-1) begin\n                scan_cnt  &lt;= '0;\n                scan_tick &lt;= 1'b1;\n            end else begin\n                scan_cnt  &lt;= scan_cnt + 1'b1;\n                scan_tick &lt;= 1'b0;\n            end\n            // mux tick\n            if (mux_cnt == MUX_DIV-1) begin\n                mux_cnt  &lt;= '0;\n                mux_tick &lt;= 1'b1;\n            end else begin\n                mux_cnt  &lt;= mux_cnt + 1'b1;\n                mux_tick &lt;= 1'b0;\n            end\n        end\n    end\nendmodule\n\n//============================================================\n// 4x4 keypad scanner (active-low matrix)\n// - Drives one column low at a time; samples rows at scan_tick\n// - Registers one key on initial detection; waits for full release\n// Mapping (row, col) → hex:\n//   Col0: [1,4,7,E]   Col1: [2,5,8,0]\n//   Col2: [3,6,9,F]   Col3: [A,B,C,D]\n//============================================================\nmodule keypad_scanner_4x4 (\n    input  logic       clk,\n    input  logic       rst_n,\n    input  logic       scan_tick,\n    output logic [3:0] col_n,     // columns driven (active-low)\n    input  logic [3:0] row_n,     // rows read    (active-low, pull-ups)\n    output logic       new_key,   // 1-cycle strobe when new key registered\n    output logic [3:0] key_hex    // hex code of the new key\n);\n    // column index (round-robin)\n    logic [1:0] col_idx;\n\n    // FSM for one-key-per-press\n    typedef enum logic [1:0] {IDLE, SCANNING, WAIT_RELEASE} state_e;\n    state_e state, state_n;\n\n    // sampled rows (convert to active-high), activity flag, decode\n    logic [3:0] row_sample;\n    logic       any_row_active;\n    logic [3:0] decoded_hex;\n\n    // drive columns: one low at a time\n    always_comb begin\n        col_n = 4'b1111;\n        col_n[col_idx] = 1'b0;\n    end\n\n    // rotate active column each scan tick\n    always_ff @(posedge clk) begin\n        if (!rst_n) col_idx &lt;= 2'd0;\n        else if (scan_tick) col_idx &lt;= col_idx + 2'd1;\n    end\n\n    // sample rows (active-low → active-high)\n    always_ff @(posedge clk) begin\n        if (!rst_n) row_sample &lt;= 4'b0000;\n        else if (scan_tick)     row_sample &lt;= ~row_n;\n    end\n\n    assign any_row_active = |row_sample;\n\n    // decode (row, col) into hex value\n    always_comb begin\n        decoded_hex = 4'h0;\n        unique case (col_idx)\n            2'd0: begin // [1,4,7,E]\n                unique case (1'b1)\n                    row_sample[0]: decoded_hex = 4'h1;\n                    row_sample[1]: decoded_hex = 4'h4;\n                    row_sample[2]: decoded_hex = 4'h7;\n                    row_sample[3]: decoded_hex = 4'hE;\n                    default:       decoded_hex = 4'h0;\n                endcase\n            end\n            2'd1: begin // [2,5,8,0]\n                unique case (1'b1)\n                    row_sample[0]: decoded_hex = 4'h2;\n                    row_sample[1]: decoded_hex = 4'h5;\n                    row_sample[2]: decoded_hex = 4'h8;\n                    row_sample[3]: decoded_hex = 4'h0;\n                    default:       decoded_hex = 4'h0;\n                endcase\n            end\n            2'd2: begin // [3,6,9,F]\n                unique case (1'b1)\n                    row_sample[0]: decoded_hex = 4'h3;\n                    row_sample[1]: decoded_hex = 4'h6;\n                    row_sample[2]: decoded_hex = 4'h9;\n                    row_sample[3]: decoded_hex = 4'hF;\n                    default:       decoded_hex = 4'h0;\n                endcase\n            end\n            default: begin // Col3: [A,B,C,D]\n                unique case (1'b1)\n                    row_sample[0]: decoded_hex = 4'hA;\n                    row_sample[1]: decoded_hex = 4'hB;\n                    row_sample[2]: decoded_hex = 4'hC;\n                    row_sample[3]: decoded_hex = 4'hD;\n                    default:       decoded_hex = 4'h0;\n                endcase\n            end\n        endcase\n    end\n\n    // FSM: latch one key on first detection, then wait for full release\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            state   &lt;= IDLE;\n            key_hex &lt;= 4'h0;\n            new_key &lt;= 1'b0;\n        end else begin\n            state   &lt;= state_n;\n            new_key &lt;= 1'b0; // default\n\n            if (scan_tick) begin\n                unique case (state)\n                    SCANNING: if (any_row_active) begin\n                        key_hex &lt;= decoded_hex; // latch once\n                        new_key &lt;= 1'b1;        // one-cycle strobe\n                    end\n                    default: /* no action */ ;\n                endcase\n            end\n        end\n    end\n\n    always_comb begin\n        state_n = state;\n        unique case (state)\n            IDLE:         state_n = SCANNING;\n            SCANNING:     state_n = (scan_tick && any_row_active) ? WAIT_RELEASE : SCANNING;\n            WAIT_RELEASE: state_n = (scan_tick && !any_row_active) ? SCANNING     : WAIT_RELEASE;\n            default:      state_n = SCANNING;\n        endcase\n    end\nendmodule\n\n//============================================================\n// Hex → 7-segment (active-low) encoder\n// Returns {dp,g,f,e,d,c,b,a}; dp kept off (1).\n//============================================================\nfunction automatic logic [7:0] hex_to_7seg_active_low (input logic [3:0] hex);\n    case (hex)\n        4'h0: hex_to_7seg_active_low = 8'b11000000;\n        4'h1: hex_to_7seg_active_low = 8'b11111001;\n        4'h2: hex_to_7seg_active_low = 8'b10100100;\n        4'h3: hex_to_7seg_active_low = 8'b10110000;\n        4'h4: hex_to_7seg_active_low = 8'b10011001;\n        4'h5: hex_to_7seg_active_low = 8'b10010010;\n        4'h6: hex_to_7seg_active_low = 8'b10000010;\n        4'h7: hex_to_7seg_active_low = 8'b11111000;\n        4'h8: hex_to_7seg_active_low = 8'b10000000;\n        4'h9: hex_to_7seg_active_low = 8'b10010000;\n        4'hA: hex_to_7seg_active_low = 8'b10001000;\n        4'hB: hex_to_7seg_active_low = 8'b10000011; // b\n        4'hC: hex_to_7seg_active_low = 8'b11000110;\n        4'hD: hex_to_7seg_active_low = 8'b10100001; // d\n        4'hE: hex_to_7seg_active_low = 8'b10000110;\n        4'hF: hex_to_7seg_active_low = 8'b10001110;\n        default: hex_to_7seg_active_low = 8'b11111111; // blank\n    endcase\nendfunction\n\n//============================================================\n// Dual 7-segment driver (time-multiplexed, active-low I/O)\n// - Alternates digits on mux_tick (e.g., 2 kHz → 1 kHz/digit)\n//============================================================\nmodule sevenseg2_mux #(\n    parameter bit ACTIVE_LOW_SEG   = 1,\n    parameter bit ACTIVE_LOW_DIGIT = 1\n)(\n    input  logic       clk,\n    input  logic       rst_n,\n    input  logic       mux_tick,\n    input  logic [3:0] hex_lo,   // most recent key (right digit)\n    input  logic [3:0] hex_hi,   // previous key    (left  digit)\n    output logic [7:0] seg,      // {dp,g,f,e,d,c,b,a}\n    output logic [1:0] dig       // digit enables [left,right]\n);\n    logic cur;             // 0=right, 1=left\n    logic [7:0] seg_raw;\n\n    always_ff @(posedge clk) begin\n        if (!rst_n) cur &lt;= 1'b0;\n        else if (mux_tick) cur &lt;= ~cur;\n    end\n\n    always_comb begin\n        seg_raw = hex_to_7seg_active_low(cur ? hex_hi : hex_lo); // table is active-low\n        seg     = (ACTIVE_LOW_SEG) ? seg_raw : ~seg_raw;\n\n        // one digit active at a time\n        unique case (cur)\n            1'b0: dig = (ACTIVE_LOW_DIGIT) ? 2'b10 : 2'b01; // right on\n            default: dig = (ACTIVE_LOW_DIGIT) ? 2'b01 : 2'b10; // left on\n        endcase\n    end\nendmodule\n\n//============================================================\n// TOP: HSOSC → tick_gen → keypad_scanner → 7-seg mux\n// I/O assumptions (adjust to board):\n//   - Keypad columns: outputs active-low col_n[3:0]\n//   - Keypad rows:    inputs  active-low row_n[3:0] (pull-ups)\n//   - 7-seg segments: seg[7:0] active-low\n//   - 7-seg digits:   dig[1:0] active-low (dig[1]=left, dig[0]=right)\n//============================================================\nmodule top_keypad_to_7seg (\n    input  logic       rst_n,      // active-low reset\n    output logic [3:0] col_n,\n    input  logic [3:0] row_n,\n    output logic [7:0] seg,\n    output logic [1:0] dig\n);\n    // ----------------------------------------------------------------\n    // Internal High-Speed Oscillator (wrapper provided by Radiant)\n    // NOTE: Set tick_gen.CLK_HZ to match your HSOSC project setting.\n    // ----------------------------------------------------------------\n    logic clk;\n    HSOSC hf_osc (\n        .CLKHF(clk)   // typical configs: 24 MHz or 48 MHz\n    );\n\n    // Timing ticks\n    logic scan_tick, mux_tick;\n    tick_gen #(\n        .CLK_HZ (24_000_000),  // &lt;-- change to 48_000_000 if HSOSC at 48 MHz\n        .SCAN_HZ(200),\n        .MUX_HZ (2000)\n    ) i_ticks (\n        .clk(clk),\n        .rst_n(rst_n),\n        .scan_tick(scan_tick),\n        .mux_tick (mux_tick)\n    );\n\n    // Keypad scanner\n    logic       new_key;\n    logic [3:0] key_hex;\n    keypad_scanner_4x4 i_scan (\n        .clk(clk),\n        .rst_n(rst_n),\n        .scan_tick(scan_tick),\n        .col_n(col_n),\n        .row_n(row_n),\n        .new_key(new_key),\n        .key_hex(key_hex)\n    );\n\n    // Shift register of last two keys: left=older, right=most-recent\n    logic [3:0] last_hi, last_lo;\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            last_hi &lt;= 4'h0;\n            last_lo &lt;= 4'h0;\n        end else if (new_key) begin\n            last_hi &lt;= last_lo;\n            last_lo &lt;= key_hex;\n        end\n    end\n\n    // 7-segment display driver (active-low)\n    sevenseg2_mux #(\n        .ACTIVE_LOW_SEG(1),\n        .ACTIVE_LOW_DIGIT(1)\n    ) i_disp (\n        .clk(clk),\n        .rst_n(rst_n),\n        .mux_tick(mux_tick),\n        .hex_lo(last_lo), // right digit\n        .hex_hi(last_hi), // left digit\n        .seg(seg),\n        .dig(dig)\n    );\nendmodule\n\n\nModular Code Attempt\nPrompt 1 gave the following:\n// One-shot key registration for a 4x4 keypad scanner.\n// Debounces press and release, latches a key code once per distinct press,\n// and emits a single-cycle pulse when a new key is registered.\nmodule keypad_one_shot #(\n  // Number of clk cycles required for a stable press OR stable release.\n  // Example: at 20 MHz, 100_000 ≈ 5 ms.\n  parameter int unsigned DEBOUNCE_CYCLES = 100_000\n)(\n  input  logic        clk,\n  input  logic        rst_n,          // active-low synchronous reset\n\n  // From the scanning front-end:\n  input  logic        any_key_raw,    // 1 if any key is currently detected\n  input  logic [3:0]  key_code_raw,   // hex code for the detected key (valid when any_key_raw=1)\n\n  // Registered, glitch-free outputs:\n  output logic        new_key_pulse,  // 1-cycle pulse when a NEW key is captured\n  output logic [3:0]  new_key_code,   // key code captured when new_key_pulse=1\n  output logic        busy            // high while a press/release cycle is in progress\n);\n\n  // --------------------------------------------------------------------------\n  // 2-FF synchronizers for raw inputs (helps with CDC/glitches from scan domain)\n  // --------------------------------------------------------------------------\n  logic any_meta, any_sync;\n  logic [3:0] kc_meta, kc_sync;\n\n  always_ff @(posedge clk) begin\n    any_meta &lt;= any_key_raw;\n    any_sync &lt;= any_meta;\n\n    kc_meta  &lt;= key_code_raw;\n    kc_sync  &lt;= kc_meta;\n  end\n\n  // --------------------------------------------------------------------------\n  // FSM with press/release debouncing and single-cycle latch (LATCH state)\n  // --------------------------------------------------------------------------\n  typedef enum logic [2:0] {\n    IDLE,           // no key pressed, waiting for press\n    DB_PRESS,       // debouncing a press\n    LATCH,          // 1-cycle pulse + capture\n    WAIT_RELEASE,   // key is held; ignore everything until release\n    DB_RELEASE      // debouncing the release\n  } state_t;\n\n  state_t state, state_n;\n\n  // Debounce counter\n  localparam int unsigned DBW = $clog2(DEBOUNCE_CYCLES+1);\n  logic [DBW-1:0] db_cnt, db_cnt_n;\n\n  // Latched code (registered output)\n  logic [3:0] code_q, code_n;\n\n  // Pulse (registered, one cycle only in LATCH)\n  logic pulse_q, pulse_n;\n\n  // Busy flag (registered for glitch-free behavior)\n  logic busy_q, busy_n;\n\n  // --------------------------------------------------------------------------\n  // Next-state / counters / outputs\n  // --------------------------------------------------------------------------\n  always_comb begin\n    // Defaults (hold)\n    state    = state;\n    state_n  = state;\n    db_cnt_n = db_cnt;\n    code_n   = code_q;\n    pulse_n  = 1'b0;        // default: no pulse\n    busy_n   = busy_q;\n\n    unique case (state)\n      IDLE: begin\n        busy_n   = 1'b0;\n        db_cnt_n = '0;\n        if (any_sync) begin\n          // Start press debounce when a key first appears\n          state_n  = DB_PRESS;\n          db_cnt_n = '0;\n          busy_n   = 1'b1;\n        end\n      end\n\n      DB_PRESS: begin\n        busy_n = 1'b1;\n        if (any_sync) begin\n          // Count stable-high cycles\n          if (db_cnt == DEBOUNCE_CYCLES-1) begin\n            // Consider the press debounced; capture the code next cycle\n            state_n  = LATCH;\n            db_cnt_n = '0;\n          end else begin\n            db_cnt_n = db_cnt + 1'b1;\n          end\n        end else begin\n          // Bounced back low; restart\n          state_n  = IDLE;\n          db_cnt_n = '0;\n        end\n      end\n\n      LATCH: begin\n        busy_n    = 1'b1;\n        pulse_n   = 1'b1;     // single-cycle pulse\n        code_n    = kc_sync;  // capture synchronized key code\n        // Move on to hold-off while key is held\n        state_n   = WAIT_RELEASE;\n        db_cnt_n  = '0;\n      end\n\n      WAIT_RELEASE: begin\n        busy_n = 1'b1;\n        db_cnt_n = '0;\n        if (!any_sync) begin\n          // Start release debounce once key goes away\n          state_n  = DB_RELEASE;\n          db_cnt_n = '0;\n        end\n      end\n\n      DB_RELEASE: begin\n        busy_n = 1'b1;\n        if (!any_sync) begin\n          // Count stable-low cycles\n          if (db_cnt == DEBOUNCE_CYCLES-1) begin\n            // Fully released; ready for next press\n            state_n  = IDLE;\n            db_cnt_n = '0;\n          end else begin\n            db_cnt_n = db_cnt + 1'b1;\n          end\n        end else begin\n          // Went high again; key pressed again before release finished\n          state_n  = WAIT_RELEASE;\n          db_cnt_n = '0;\n        end\n      end\n\n      default: begin\n        state_n  = IDLE;\n        db_cnt_n = '0;\n        busy_n   = 1'b0;\n      end\n    endcase\n  end\n\n  // --------------------------------------------------------------------------\n  // State & output registers\n  // --------------------------------------------------------------------------\n  always_ff @(posedge clk) begin\n    if (!rst_n) begin\n      state        &lt;= IDLE;\n      db_cnt       &lt;= '0;\n      code_q       &lt;= 4'h0;\n      pulse_q      &lt;= 1'b0;\n      busy_q       &lt;= 1'b0;\n    end else begin\n      state        &lt;= state_n;\n      db_cnt       &lt;= db_cnt_n;\n      code_q       &lt;= code_n;\n      pulse_q      &lt;= pulse_n;\n      busy_q       &lt;= busy_n;\n    end\n  end\n\n  // --------------------------------------------------------------------------\n  // Drive module outputs\n  // --------------------------------------------------------------------------\n  assign new_key_pulse = pulse_q;\n  assign new_key_code  = code_q;\n  assign busy          = busy_q;\n\nendmodule\nPrompt 2 gave the following:\n// 4x4 matrix keypad scanner (active-low columns, active-low rows).\n// - Cycles columns at a divided scan rate.\n// - Detects exactly one key at a time (locks while pressed).\n// - Reports a stable hex key code (0-9, A-D, E=\"*\", F=\"#\").\n// - Provides \"any_key\" flag while a key is held.\n//\n// Standard keypad layout used:\n//\n//        C0   C1   C2   C3\n// R0:    1    2    3    A(10)\n// R1:    4    5    6    B(11)\n// R2:    7    8    9    C(12)\n// R3:    E(*) 0    F(#) D(13)\n//\n// Notes:\n// * Columns are driven active-low, one at a time (others high).\n// * Rows are sampled active-low.\n// * While a key is held, the scanner holds that column asserted and keeps\n//   reporting the same code; other keys are ignored until release.\n//\n// Tune SCAN_DIV for your system clock to achieve a column tick of ~1–5 kHz.\n// At 20 MHz: SCAN_DIV=5_000 -&gt; 4 kHz per column, ~1 kHz full-frame scan.\nmodule keypad_scanner #(\n  parameter int unsigned SCAN_DIV = 5_000  // clk cycles per column step\n)(\n  input  logic        clk,\n  input  logic        rst_n,        // active-low synchronous reset\n\n  // Matrix connections (external pull-ups recommended):\n  input  logic [3:0]  rows_n,       // row inputs, active-low\n  output logic [3:0]  cols_n,       // column drives, active-low (one at a time)\n\n  // Results:\n  output logic        any_key,      // 1 while a key is pressed and held\n  output logic [3:0]  key_code      // stable hex code while any_key=1\n);\n\n  // --------------------------------------------------------------------------\n  // Synchronize row inputs (they are asynchronous to clk / mechanical)\n  // --------------------------------------------------------------------------\n  logic [3:0] rows_meta, rows_sync_n;\n\n  always_ff @(posedge clk) begin\n    rows_meta   &lt;= rows_n;\n    rows_sync_n &lt;= rows_meta;\n  end\n\n  // Positive-sense rows for easier logic (1 = pressed, 0 = idle):\n  wire [3:0] rows_p = ~rows_sync_n; // active-high: 1 means that row is asserted\n\n  // --------------------------------------------------------------------------\n  // Scan clock divider -&gt; generates a single-cycle 'scan_tick'\n  // --------------------------------------------------------------------------\n  localparam int unsigned DW = $clog2(SCAN_DIV);\n  logic [DW-1:0] div_cnt;\n  logic          scan_tick;\n\n  always_ff @(posedge clk) begin\n    if (!rst_n) begin\n      div_cnt   &lt;= '0;\n      scan_tick &lt;= 1'b0;\n    end else begin\n      if (div_cnt == SCAN_DIV-1) begin\n        div_cnt   &lt;= '0;\n        scan_tick &lt;= 1'b1;\n      end else begin\n        div_cnt   &lt;= div_cnt + 1'b1;\n        scan_tick &lt;= 1'b0;\n      end\n    end\n  end\n\n  // --------------------------------------------------------------------------\n  // Column index and drive (active-low one-hot)\n  // --------------------------------------------------------------------------\n  logic [1:0] col_idx_q, col_idx_n;\n  logic [3:0] cols_drive_q;\n\n  // Active-low one-hot from index\n  function automatic logic [3:0] col_onehot_n(input logic [1:0] idx);\n    logic [3:0] oh;\n    begin\n      oh = 4'b1111;\n      unique case (idx)\n        2'd0: oh = 4'b1110;\n        2'd1: oh = 4'b1101;\n        2'd2: oh = 4'b1011;\n        2'd3: oh = 4'b0111;\n      endcase\n      return oh;\n    end\n  endfunction\n\n  // --------------------------------------------------------------------------\n  // FSM to scan and hold while a key is pressed\n  // --------------------------------------------------------------------------\n  typedef enum logic [1:0] {\n    SCAN  = 2'b00,   // rotate columns and look for a press\n    HOLD  = 2'b01    // keep the detected column asserted; wait for release\n  } state_t;\n\n  state_t state_q, state_n;\n\n  // Latched row/column of the detected key (for code generation)\n  logic [1:0] latched_col_q, latched_col_n;\n  logic [1:0] latched_row_q, latched_row_n;\n\n  // Output registers\n  logic        any_key_q,  any_key_n;\n  logic [3:0]  key_code_q, key_code_n;\n\n  // Priority row pick (first asserted row wins: R0 highest priority)\n  function automatic logic [1:0] pick_row(input logic [3:0] rows_active);\n    logic [1:0] r;\n    begin\n      // Priority: R0, then R1, then R2, then R3\n      if (rows_active[0])      r = 2'd0;\n      else if (rows_active[1]) r = 2'd1;\n      else if (rows_active[2]) r = 2'd2;\n      else                     r = 2'd3; // if none set, caller won't use result\n      return r;\n    end\n  endfunction\n\n  // Any row pressed?\n  wire any_row_pressed = |rows_p;\n\n  // Hex code lookup from (row, col) per the layout in the header.\n  function automatic logic [3:0] key_from_rc(input logic [1:0] r, input logic [1:0] c);\n    logic [3:0] code;\n    begin\n      unique case (r)\n        2'd0: begin // R0: 1,2,3,A\n          unique case (c)\n            2'd0: code = 4'h1;\n            2'd1: code = 4'h2;\n            2'd2: code = 4'h3;\n            2'd3: code = 4'hA;\n          endcase\n        end\n        2'd1: begin // R1: 4,5,6, B\n          unique case (c)\n            2'd0: code = 4'h4;\n            2'd1: code = 4'h5;\n            2'd2: code = 4'h6;\n            2'd3: code = 4'hB;\n          endcase\n        end\n        2'd2: begin // R2: 7,8,9, C\n          unique case (c)\n            2'd0: code = 4'h7;\n            2'd1: code = 4'h8;\n            2'd2: code = 4'h9;\n            2'd3: code = 4'hC;\n          endcase\n        end\n        default: begin // R3: E(*),0,F(#), D\n          unique case (c)\n            2'd0: code = 4'hE; // '*'\n            2'd1: code = 4'h0;\n            2'd2: code = 4'hF; // '#'\n            2'd3: code = 4'hD;\n          endcase\n        end\n      endcase\n      return code;\n    end\n  endfunction\n\n  // Next-state / outputs\n  always_comb begin\n    // Hold-by-default\n    state_n        = state_q;\n    col_idx_n      = col_idx_q;\n    cols_drive_q   = col_onehot_n(col_idx_q);\n\n    latched_col_n  = latched_col_q;\n    latched_row_n  = latched_row_q;\n\n    any_key_n      = any_key_q;\n    key_code_n     = key_code_q;\n\n    unique case (state_q)\n      SCAN: begin\n        // Rotate columns at scan_tick\n        if (scan_tick) begin\n          col_idx_n    = col_idx_q + 2'd1;\n          cols_drive_q = col_onehot_n(col_idx_n);\n        end\n\n        // Sample rows for the *currently driven* column\n        if (any_row_pressed) begin\n          // Lock onto the first asserted row; hold this column\n          latched_col_n = col_idx_q;\n          latched_row_n = pick_row(rows_p);\n          key_code_n    = key_from_rc(latched_row_n, latched_col_n);\n          any_key_n     = 1'b1;\n          state_n       = HOLD;\n          // keep cols_drive_q at current column (do not advance while HOLD)\n        end\n      end\n\n      HOLD: begin\n        // Keep driving only the latched column while pressed\n        cols_drive_q = col_onehot_n(latched_col_q);\n        // Maintain outputs while any row is still asserted\n        if (!any_row_pressed) begin\n          // Released: clear flag and return to scanning next column\n          any_key_n = 1'b0;\n          state_n   = SCAN;\n          // Resume scanning from column after the held one\n          col_idx_n = latched_col_q + 2'd1;\n        end\n      end\n\n      default: begin\n        state_n = SCAN;\n      end\n    endcase\n  end\n\n  // Registers\n  always_ff @(posedge clk) begin\n    if (!rst_n) begin\n      state_q       &lt;= SCAN;\n      col_idx_q     &lt;= 2'd0;\n      latched_col_q &lt;= 2'd0;\n      latched_row_q &lt;= 2'd0;\n      any_key_q     &lt;= 1'b0;\n      key_code_q    &lt;= 4'h0;\n    end else begin\n      state_q       &lt;= state_n;\n      col_idx_q     &lt;= col_idx_n;\n      latched_col_q &lt;= latched_col_n;\n      latched_row_q &lt;= latched_row_n;\n      any_key_q     &lt;= any_key_n;\n      key_code_q    &lt;= key_code_n;\n    end\n  end\n\n  // Drive external signals (registered/glitch-free)\n  assign cols_n  = cols_drive_q; // active-low one-hot\n  assign any_key = any_key_q;\n  assign key_code= key_code_q;\n\nendmodule\nPrompt 3 gave the following:\n// Top-level: 4x4 keypad → last-two keys → dual 7-seg display (multiplexed)\n// Target: Lattice iCE40 UP5K. Root clock from internal HF oscillator.\n//\n// External interface (typical):\n//   - rows_n[3:0]  : keypad rows, active-low inputs (external pull-ups recommended)\n//   - cols_n[3:0]  : keypad columns, active-low outputs (one driven low at a time)\n//   - seg[6:0]     : seven-seg segment outputs (a..g). Polarity depends on your board.\n//   - dig_en_n[1:0]: active-low digit enables: [0]=left (older), [1]=right (most recent)\n//   - rst_n        : active-low synchronous reset (can tie high if unused)\n//\n// Notes:\n// - Refresh runs at ~1 kHz per digit (2 kHz frame) by default to avoid flicker.\n// - Display updates only when a NEW key is registered by the one-shot block.\nmodule top_keypad_last2 (\n  input  logic        rst_n,        // active-low synchronous reset\n  input  logic [3:0]  rows_n,       // keypad rows (active-low)\n  output logic [3:0]  cols_n,       // keypad columns (active-low)\n  output logic [6:0]  seg,          // segments a..g (polarity per your sevenSegment)\n  output logic [1:0]  dig_en_n      // digit enables, active-low: [0]=left, [1]=right\n);\n\n  // ==========================================================================\n  // Internal HF oscillator (root clock)\n  // ==========================================================================\n  // Toolchain note: some flows use SB_HFOSC; the project here uses HSOSC.\n  // If your tool complains, rename HSOSC→SB_HFOSC and keep ports the same.\n  logic clk_hf;\n  HSOSC hf_osc (\n    .CLKHFEN (1'b1),\n    .CLKHFPU (1'b1),\n    .CLKHF   (clk_hf)\n  );\n\n  // ==========================================================================\n  // Parameters (tune if you know your actual CLK_HZ)\n  // ==========================================================================\n  // iCE40 HFOSC commonly configured around ~20–48 MHz. Set appropriately.\n  localparam int unsigned CLK_HZ           = 20_000_000;\n\n  // Keypad scan column step ~2 kHz → ~500 Hz full-frame (4 columns).\n  // (The scanner also has its own divider; this sets that parameter.)\n  localparam int unsigned SCAN_STEP_HZ     = 2_000;\n  localparam int unsigned SCAN_DIV         = (CLK_HZ / SCAN_STEP_HZ);\n\n  // One-shot debounce ~5 ms for both press and release:\n  localparam int unsigned DEBOUNCE_US      = 5_000;\n  localparam int unsigned DEBOUNCE_CYCLES  = (CLK_HZ / 1_000_000) * DEBOUNCE_US;\n\n  // 7-seg refresh: ~1 kHz per digit (2 kHz frame).\n  localparam int unsigned DIGIT_HZ         = 1_000;\n  localparam int unsigned REFRESH_DIV      = (CLK_HZ / (2 * DIGIT_HZ)); // toggles between two digits\n\n  // ==========================================================================\n  // Keypad scanner: cycles columns, samples rows, holds one key while pressed\n  // ==========================================================================\n  logic        scan_any_key;\n  logic [3:0]  scan_key_code;\n\n  keypad_scanner #(\n    .SCAN_DIV(SCAN_DIV)\n  ) u_scan (\n    .clk      (clk_hf),\n    .rst_n    (rst_n),\n    .rows_n   (rows_n),\n    .cols_n   (cols_n),\n    .any_key  (scan_any_key),\n    .key_code (scan_key_code)\n  );\n\n  // ==========================================================================\n  // One-shot registrar: debounced single-cycle pulse per DISTINCT press\n  // ==========================================================================\n  logic        new_key_pulse;\n  logic [3:0]  new_key_code;\n  logic        press_busy; // (not used by top; available for debug)\n\n  keypad_one_shot #(\n    .DEBOUNCE_CYCLES(DEBOUNCE_CYCLES)\n  ) u_oneshot (\n    .clk           (clk_hf),\n    .rst_n         (rst_n),\n    .any_key_raw   (scan_any_key),\n    .key_code_raw  (scan_key_code),\n    .new_key_pulse (new_key_pulse),\n    .new_key_code  (new_key_code),\n    .busy          (press_busy)\n  );\n\n  // ==========================================================================\n  // Last-two keys shift register (update ONLY on new_key_pulse)\n  // Left digit = older, Right digit = most recent\n  // ==========================================================================\n  logic [3:0] key_old_q, key_new_q;\n\n  always_ff @(posedge clk_hf) begin\n    if (!rst_n) begin\n      key_old_q &lt;= 4'h0;\n      key_new_q &lt;= 4'h0;\n    end else begin\n      if (new_key_pulse) begin\n        key_old_q &lt;= key_new_q;     // older  ← previous most recent\n        key_new_q &lt;= new_key_code;  // recent ← new\n      end\n    end\n  end\n\n  // ==========================================================================\n  // Seven-seg refresh (2:1 mux) with registered outputs for no ghosting\n  // - We toggle which digit is enabled at a constant rate.\n  // - Segment data is registered at the same time.\n  // ==========================================================================\n  localparam int unsigned REFRESH_W = (REFRESH_DIV &gt; 1) ? $clog2(REFRESH_DIV) : 1;\n  logic [REFRESH_W-1:0] refresh_cnt;\n  logic                 refresh_tick;\n  logic                 which_digit_q; // 0 = left/older, 1 = right/recent\n\n  always_ff @(posedge clk_hf) begin\n    if (!rst_n) begin\n      refresh_cnt  &lt;= '0;\n      refresh_tick &lt;= 1'b0;\n    end else begin\n      if (refresh_cnt == REFRESH_DIV-1) begin\n        refresh_cnt  &lt;= '0;\n        refresh_tick &lt;= 1'b1;\n      end else begin\n        refresh_cnt  &lt;= refresh_cnt + 1'b1;\n        refresh_tick &lt;= 1'b0;\n      end\n    end\n  end\n\n  // Toggle active digit on each tick\n  always_ff @(posedge clk_hf) begin\n    if (!rst_n) begin\n      which_digit_q &lt;= 1'b0;\n    end else if (refresh_tick) begin\n      which_digit_q &lt;= ~which_digit_q;\n    end\n  end\n\n  // Segment encoder instances (combinational), selected then registered\n  // If your sevenSegment is a function, adapt accordingly.\n  logic [6:0] seg_left_w, seg_right_w;\n  logic [6:0] seg_reg_q;\n\n  sevenSegment u_seg_left  (.in(key_old_q), .seg(seg_left_w));\n  sevenSegment u_seg_right (.in(key_new_q), .seg(seg_right_w));\n\n  // Register the selected segment pattern and digit enables together\n  always_ff @(posedge clk_hf) begin\n    if (!rst_n) begin\n      seg_reg_q &lt;= '0;\n      // Both disables high (inactive) — active-low enables\n      dig_en_n  &lt;= 2'b11;\n    end else if (refresh_tick) begin\n      if (which_digit_q == 1'b0) begin\n        // Show LEFT (older)\n        seg_reg_q &lt;= seg_left_w;\n        dig_en_n  &lt;= 2'b10; // enable [0]=left low, [1]=right high\n      end else begin\n        // Show RIGHT (most recent)\n        seg_reg_q &lt;= seg_right_w;\n        dig_en_n  &lt;= 2'b01; // enable [1]=right low, [0]=left high\n      end\n    end\n  end\n\n  // Drive segment outputs\n  assign seg = seg_reg_q;\n\nendmodule\nI found it interesting to learn that there are different ways to approach solution to problems in digital design. Monolithic design seemed simple to understand, synthesize and debug because I believe it was even more straigthforward for the LLM to debug any errors in it’s code. When I got to the Modular design, the FSM was getting entangled in it’s different signals across the 3 major function modules. That sometimes it would misstep and call a different signal and use it for the wrong lines. It was a tough job for me as well trying to figure out errors in 400 code lines that I didn’t write. Overall, the design followed a familiar roadmap but the implementation was a little different because the LLM was focused more on passing the constraints that it implemented some redundant measures to counter things like bouncing or timing errors. This might be a good practice but it uses a lot of resources and makes the code more complex. Overall, I learn new things from the LLM everyweek when we use it. I liked the use of parameter which let’s me set global variables that I can change easily without scouring through my entire code or risk errors by mistyping the number itself. This week, I learnt that redundant functionality can be helpful in case you expect your logic to slip somewhere so you can counter the errors."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "E155 Lab 5: Interrupts",
    "section": "",
    "text": "In this lab, the MCU was used to interface with a quadrature encoder to measure the speed (in revolutions/sec) and direction (Clockwise/anti-clockwise) of a DC motor. The MCU did this by using the encoder mode of the advanced timer, TIM1, and using the basic timer, TIM6, to sample the incoming wave, calculating position difference and direction. In the end, the design could display the motor speed as well as the direction, accounting for instances when the motor is also at rest.\nThe quadrature encoder in this lab uses a motor to trigger Hall effect sensors, which output two square waves that are \\(90^\\circ\\) out of phase. This phase difference is what was used to determine the period of the waves and hence calculate the speed and direction of the motor."
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "E155 Lab 5: Interrupts",
    "section": "",
    "text": "In this lab, the MCU was used to interface with a quadrature encoder to measure the speed (in revolutions/sec) and direction (Clockwise/anti-clockwise) of a DC motor. The MCU did this by using the encoder mode of the advanced timer, TIM1, and using the basic timer, TIM6, to sample the incoming wave, calculating position difference and direction. In the end, the design could display the motor speed as well as the direction, accounting for instances when the motor is also at rest.\nThe quadrature encoder in this lab uses a motor to trigger Hall effect sensors, which output two square waves that are \\(90^\\circ\\) out of phase. This phase difference is what was used to determine the period of the waves and hence calculate the speed and direction of the motor."
  },
  {
    "objectID": "labs/lab5/lab5.html#experiment-setup-and-design-overview",
    "href": "labs/lab5/lab5.html#experiment-setup-and-design-overview",
    "title": "E155 Lab 5: Interrupts",
    "section": "Experiment Setup and Design Overview",
    "text": "Experiment Setup and Design Overview\nThe main purpose of the lab was to use interrupts to interface with the encoder by triggering interrupts on the edges of the encoder pulses following a sampling time of \\(0.083 s\\), to find the difference in positions, which was then used to determine both the direction and speed of the motor. The design measured and displayed the motor speed in rev/s with an update of at least \\(1Hz\\).\n\nMCU Setup Logic\nTo set up the MCU for the desired function, we had to configure different modules to run the system clock, set up timers, and configure GPIO. This time, we were allowed to use the CMSIS library, which meant that all the register structs for the MCU were predefined, which simplified the code and design. The libraries also had some added functionality from the functions and logic set up in the previous lab, as some of it, such as configuring timers, was used in this lab as well. The given motor had \\(PPR = 408\\), so with a quadrature encoder, I set PULSES_PER_REV  =  1632.\nI leveraged encoder interface mode 3 for TIM1, which allows me to connect an incremental encoder directly to the timer. Pins PA8 and PA9 were configured for alternate function and connected to the two TIM1 channels. The signals from the encoder came in through these pins, and each complete quadrature cycle (both rising and falling edges of both channels) increments or decrements the counter. The counter direction is set in the hardware direction bit (obtained from TIM1-&gt;CR1 & TIM_CR1_DIR) and is also used to determine the effective direction and position of the motor. The counter limit, ARR, was set to ARR = PULSES_PER_REV - 1 so TIM1 counter wraps once per mechanical revolution. This wrap-around logic identifies the difference between the past recorded and current motor position (essentially 2 different values of TIM1 counter) and turns it into the smallest, correctly signed motion across a wrap. The sign of this difference is what is used to determine the direction. The difference is mapped into the nearest step around a circle by comparing it to PULSES_PER_REV /2. If less, I subtract PULSES_PER_REV and vice versa. However, if a sample occurs at the half turn, I use the direction provided by the TIM1 hardware direction bit. This logic ensures proper signage every time: for example, moving from \\(400\\) to \\(10\\) would give a difference of \\(-390\\). Which would be the wrong motor direction, but after applying the wrap logic, I get \\(18\\), which shows me the actual step completed and the right direction (sign).\nA separate timer, TIM6, runs at the sample period of \\(0.083s\\) with a \\(1KHz\\) clock (obtained by prescaling down the \\(4MHz\\) system clock). TIM6 ISR snapshots TIM1-&gt;CNT and the value is recorded and used to determine motor position. The major concern with this sampling approach aliasing. My safe zone is valid as long as the shaft moves less than half a revolution per sample. This means the chosen sample period of 0.083s is valid as long as \\(rps*0.083&lt; 0.5\\), which means my wrap-around logic works up to \\(\\approx6Rev/s\\) (360rpm), which is more than enough since the given motor does \\(2Rev/s\\) at 10V and around \\(5Rev/s\\) at 24V.\n\n\nImplementation\nThe main function communicates with TIM6 interrupt handler through only a few set of select signals that set up the whole functionality. TIM6 is configured as a basic timer with a prescaler and ARR to generate interrupts every 0.083s and sets UIF bit. On each interrupt, the handler reads the current value of TIM1-&gt;CNT and compares it to the previous value. The difference is adjusted for wrap-around using the logic described above and the ISR sets sample = 1 signaling the main loop to calculate and print values. The main loop waits for the interrupt to update the position and direction based on the difference calculated in the IQR function. The loop would print values and then reset the sample flag. This can be seen in Figure 1 below:\n\n\n\n\n\n\nFigure 1: Interrupt Design Flowchart\n\n\n\nAn alternative to periodic-interrupt sampling is polling, where the TIM6 update interrupt flag (UIF) is checked frequently in the main() loop, and samples are taken when the flag is set. While polling can be simpler to implement, it is generally less efficient because the CPU must continuously check the flag, consuming more processing resources and potentially missing other important tasks such as printing, calculation, or reading encoder signals. If we were to ensure the CPU does all of this while polling, the design would have a timing error that would invalidate the speed measurements.\nGiven the system parameters (clk, sample period, PPR) described above, the implementation follows the baseline math below assuming \\(5 Rev/s\\) top speed:\n\nCounts per sample: \\(\\text{RPS}*\\text{T\\_sample}*\\text{PPR} = 5*0.083*1632 \\approx 677 \\text{counts}\\), a value that is well below the alias limit of \\(\\frac{\\text{PPR}}{2} = 816\\text{counts}\\)\nCounts per second: \\(\\text{PPR}*\\text{RPS} = 1632*5 = 8160\\text{counts/s}\\)\n\nArm estimates the Core-M4 ISR latency(\\(\\epsilon\\)) to be between \\(10-25\\mu s\\). With TIM6 ISR triggering every 83ms, the relative timing error is \\(\\frac{\\epsilon}{\\text{T\\_sample}} = \\frac{25\\mu s}{83ms} \\approx 0.03\\%\\). Therefore the counting error would be \\(677\\text{counts}*0.03\\% \\approx 0.2\\text{counts}\\) which is very small compared to \\(677\\).\nWith a polling approach, the relative timing error depends on the polling interval, which is determined by how fast the main loop iterates. This interval can be easily affected by other tasks that the CPU must run simultaneously or in sequence. To match the same timing error as the interrupt method, the polling interval would need to be as short as \\(25\\mu s\\). However, this interval only accounts for looping overhead—assuming 200 cycles at a 4MHz clock. When additional functions such as printing are included, CPU resources are stretched further and the interval can go as high as \\(20-50ms\\) assuming fasted baud rate. Given a polling inteval \\(\\tau=20ms\\), the timing error is \\(\\frac{(\\frac{\\tau}{2})}{\\text{T\\_sample}} = \\frac{(\\frac{20ms}{2})}{\\text{83ms}} \\approx 12.05\\%\\). Therefore the counting error would be \\(677\\text{counts}*12.05\\% \\approx 82\\text{counts}\\) which is magnitude above the error from ISR.\nThis shows that using interrupts for encoder sampling is much more accurate and efficient than polling, as it minimizes timing errors and ensures reliable speed measurements."
  },
  {
    "objectID": "labs/lab5/lab5.html#hardware-setup",
    "href": "labs/lab5/lab5.html#hardware-setup",
    "title": "E155 Lab 5: Interrupts",
    "section": "Hardware Setup",
    "text": "Hardware Setup\nAfter verifying the MCU logic, the code was uploaded on the hardware for testing using Segger Embedded Studio. The quadrature encoder was connected to the +5V and GND from the MCU, and the signals were connected to the 5V-tolerant pins A8 and A9. The motor itself was connected to the lab power supply to with the ability to feed both negative and positive voltages to the motor in the range ±25V.\n\n\n\n\n\n\nFigure 2: Quadrature Encoder And Motor Wiring Setup\n\n\n\nThe hardware responded properly as shown in the example video below:\n\n\n\nVideo\n\n\nFigure 3: Hardware Execution Example Reading Motor Speed and Showing Direction"
  },
  {
    "objectID": "labs/lab5/lab5.html#conclusion",
    "href": "labs/lab5/lab5.html#conclusion",
    "title": "E155 Lab 5: Interrupts",
    "section": "Conclusion",
    "text": "Conclusion\nThis lab took around 14 hours to complete. I invested a lot of time in making sure my sampling and wrap-around logic lines up properly for the intended approach in reading the speed of the motor. I had struggles mainly with sampling as I was aliasing a lot of times and the wrap around math was wrong because the PPR was divided in the timer setup initially but now it is all fixed and the setup works properly as shown in Figure 3."
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-prototype-summary",
    "href": "labs/lab5/lab5.html#ai-prototype-summary",
    "title": "E155 Lab 5: Interrupts",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe goal was to use AI to generate an interrupt based approach to interface a quadrature encoder. I used chatgpt5 and it generated the code snippet linked below.\n// STM32L432KC - Quadrature via EXTI (PA0/PA1) + TIM7 speed print\n// - A: PA0 -&gt; EXTI0\n// - B: PA1 -&gt; EXTI1\n// Prints speed (rev/s, RPM) and direction (\"FWD\"/\"REV\"/\"STOP\") at SAMPLE_HZ\n\n#include \"stm32l4xx.h\"\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;   // assume retargeted to UART/SWV\n\n// ====== USER CONFIG ======\n#define ENCODER_CPR      408u      // counts per revolution per channel (datasheet CPR)\n#define SAMPLE_HZ        50u        // speed print rate (Hz) -&gt; 20 ms period\n#define TIMER_CLK_HZ     80000000u  // TIM7 input clock (APB1 timer clock). Adjust to your system.\n\n// Derived: 4x decoding edges per rev\n#define EDGES_PER_REV    ( (uint32_t)ENCODER_CPR * 4u )\n\n// ====== Globals (shared with ISRs) ======\nstatic volatile int32_t enc_pos = 0;     // accumulated 4x edges\nstatic volatile int8_t  last_step = 0;   // last +1/-1/0 (for direction)\nstatic volatile uint8_t prev_ab = 0;     // previous AB state (00,01,11,10 encoded as 0..3)\n\n// 4-bit LUT: (prev&lt;&lt;2 | curr) -&gt; {-1,0,+1}\nstatic const int8_t quad_lut[16] = {\n/* 00-&gt;00 */  0, /*00-&gt;01*/ +1, /*00-&gt;11*/ -1, /*00-&gt;10*/  0,\n              -1,  0,        0,       +1,\n              +1,  0,        0,       -1,\n               0, -1,       +1,        0\n};\n\n// ====== Helpers ======\nstatic inline uint8_t read_ab(void) {\n    uint32_t idr = GPIOA-&gt;IDR;\n    uint8_t a = (idr &gt;&gt; 0) & 1u;   // PA0\n    uint8_t b = (idr &gt;&gt; 1) & 1u;   // PA1\n    return (uint8_t)((a &lt;&lt; 1) | b);\n}\n\nstatic inline void quad_step(void) {\n    uint8_t curr = read_ab();\n    int8_t delta = quad_lut[(prev_ab &lt;&lt; 2) | curr];\n    if (delta) {\n        enc_pos += delta;\n        last_step = delta; // remember sign for direction\n    }\n    prev_ab = curr;\n}\n\n// ====== GPIO + EXTI init for PA0/PA1 ======\nstatic void enc_exti_init(void) {\n    // Clocks\n    RCC-&gt;AHB2ENR  |= RCC_AHB2ENR_GPIOAEN;\n    RCC-&gt;APB2ENR  |= RCC_APB2ENR_SYSCFGEN;\n\n    // PA0, PA1 as inputs with pull-up\n    GPIOA-&gt;MODER  &= ~((3u&lt;&lt;(0*2)) | (3u&lt;&lt;(1*2)));\n    GPIOA-&gt;PUPDR  &= ~((3u&lt;&lt;(0*2)) | (3u&lt;&lt;(1*2)));\n    GPIOA-&gt;PUPDR  |=  ((1u&lt;&lt;(0*2)) | (1u&lt;&lt;(1*2)));  // PU\n\n    // Route to EXTI0/1 from port A\n    SYSCFG-&gt;EXTICR[0] &= ~((0xFu&lt;&lt;0) | (0xFu&lt;&lt;4)); // PA for EXTI0/1\n\n    // Both edges on A and B\n    EXTI-&gt;IMR1  |=  (1u&lt;&lt;0) | (1u&lt;&lt;1);\n    EXTI-&gt;RTSR1 |=  (1u&lt;&lt;0) | (1u&lt;&lt;1);\n    EXTI-&gt;FTSR1 |=  (1u&lt;&lt;0) | (1u&lt;&lt;1);\n\n    // Initial AB state\n    prev_ab = read_ab();\n\n    // NVIC\n    NVIC_SetPriority(EXTI0_IRQn, 2);\n    NVIC_SetPriority(EXTI1_IRQn, 2);\n    NVIC_EnableIRQ(EXTI0_IRQn);\n    NVIC_EnableIRQ(EXTI1_IRQn);\n}\n\n// ====== TIM7 periodic (speed print) ======\nstatic void tim7_init_sample_timer(void) {\n    // Enable TIM7 clock\n    RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM7EN;\n\n    // Compute PSC/ARR for SAMPLE_HZ\n    // We aim for: TIM7 tick = 1 MHz (1 us) to keep ARR small & precise\n    uint32_t target_tick_hz = 1000000u; // 1 MHz\n    uint32_t psc = (TIMER_CLK_HZ / target_tick_hz);\n    if (psc == 0) psc = 1;\n    psc -= 1;\n    TIM7-&gt;PSC = (uint16_t)psc;\n\n    // ARR = tick_hz / SAMPLE_HZ\n    uint32_t tick_hz = TIMER_CLK_HZ / (psc + 1u);\n    uint32_t arr = tick_hz / SAMPLE_HZ;\n    if (arr == 0) arr = 1;\n    arr -= 1;\n    TIM7-&gt;ARR = (uint16_t)arr;\n\n    TIM7-&gt;EGR  = TIM_EGR_UG;          // update registers\n    TIM7-&gt;SR   = 0;                   // clear flags\n    TIM7-&gt;DIER = TIM_DIER_UIE;        // update interrupt\n    NVIC_SetPriority(TIM7_IRQn, 3);\n    NVIC_EnableIRQ(TIM7_IRQn);\n    TIM7-&gt;CR1  = TIM_CR1_CEN;         // start\n}\n\n// ====== Interrupts ======\nvoid EXTI0_IRQHandler(void) {           // A changed\n    if (EXTI-&gt;PR1 & (1u&lt;&lt;0)) {\n        EXTI-&gt;PR1 = (1u&lt;&lt;0);           // clear\n        quad_step();\n    }\n}\nvoid EXTI1_IRQHandler(void) {           // B changed\n    if (EXTI-&gt;PR1 & (1u&lt;&lt;1)) {\n        EXTI-&gt;PR1 = (1u&lt;&lt;1);           // clear\n        quad_step();\n    }\n}\n\nvoid TIM7_IRQHandler(void) {\n    static int32_t last_pos = 0;\n\n    if (TIM7-&gt;SR & TIM_SR_UIF) {\n        TIM7-&gt;SR &= ~TIM_SR_UIF;\n\n        // Snapshot position atomically (enc_pos is 32-bit aligned, read is atomic on Cortex-M4)\n        int32_t now = enc_pos;\n        int32_t delta = now - last_pos;\n        last_pos = now;\n\n        // Convert delta edges to rev/s\n        // revs_in_window = delta / EDGES_PER_REV\n        // speed_rps = revs_in_window * SAMPLE_HZ\n        float speed_rps = ((float)delta / (float)EDGES_PER_REV) * (float)SAMPLE_HZ;\n        float rpm = speed_rps * 60.0f;\n\n        // Direction: prefer sign of delta, otherwise use last edge sign, otherwise STOP\n        const char *dir = \"STOP\";\n        if (delta &gt; 0)      dir = \"FWD\";\n        else if (delta &lt; 0) dir = \"REV\";\n        else if (last_step &gt; 0) dir = \"FWD\";\n        else if (last_step &lt; 0) dir = \"REV\";\n\n        // Optional: deadband small jitter around zero\n        const float eps_rps = 0.002f; // ~0.12 RPM\n        if (speed_rps &gt; -eps_rps && speed_rps &lt; eps_rps) {\n            speed_rps = 0.0f;\n            rpm = 0.0f;\n        }\n\n        // Print once per sample\n        printf(\"Speed: %.3f rev/s (%.1f RPM), Dir: %s, Pos: %ld edges\\r\\n\",\n               speed_rps, rpm, dir, (long)now);\n    }\n}\n\n// ====== Example main ======\nint main(void) {\n    // (Init clocks here if not already done by your startup/system code)\n    // (Init UART or SWO for printf elsewhere)\n\n    enc_exti_init();\n    tim7_init_sample_timer();\n\n    while (1) {\n        __WFI(); // sleep until interrupt (optional, saves power/CPU)\n    }\n}\nAfter trying the code in my setup it didn’t work. The reasoning comes close to mine in terms of using a sampling timer but it used GPIO interrupts as opposed to timer encoder mode which I used. The LLM seems to be concerned about CPU resource usage which is good and has code to ensure the CPU uses less resources such as sleeping when an interrupt isn’t triggered. There is also code to ensure smooth filtering to remove encoder signal noise. Another great thing the LLM impemented is NVIM_SetPriority() which sets the order in which interrupts from the GPIOs and the timer are handled. It used this to ensure that encoder edges are processed before the speed readout updates."
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "E155 Lab 7: Hardware Accelerated AES-128 Encryption",
    "section": "",
    "text": "In this lab, the MCU and FPGA were used together to implement a hardware-accelerated version of the Advanced Encryption Standard (AES) for 128-bit data encryption. The MCU stored the plaintext, cipher key, and expected ciphertext, and transmitted the plaintext and key to the FPGA via the SPI interface. The FPGA performed the AES encryption according to the NIST-197 standard and then returned the resulting ciphertext to the MCU. Finally, the MCU compared the received ciphertext to the expected value and indicated the success or failure of the encryption process through output signals lighting either a green (success) or red (failure) LED."
  },
  {
    "objectID": "labs/lab7/lab7.html#introduction",
    "href": "labs/lab7/lab7.html#introduction",
    "title": "E155 Lab 7: Hardware Accelerated AES-128 Encryption",
    "section": "",
    "text": "In this lab, the MCU and FPGA were used together to implement a hardware-accelerated version of the Advanced Encryption Standard (AES) for 128-bit data encryption. The MCU stored the plaintext, cipher key, and expected ciphertext, and transmitted the plaintext and key to the FPGA via the SPI interface. The FPGA performed the AES encryption according to the NIST-197 standard and then returned the resulting ciphertext to the MCU. Finally, the MCU compared the received ciphertext to the expected value and indicated the success or failure of the encryption process through output signals lighting either a green (success) or red (failure) LED."
  },
  {
    "objectID": "labs/lab7/lab7.html#aes-overview",
    "href": "labs/lab7/lab7.html#aes-overview",
    "title": "E155 Lab 7: Hardware Accelerated AES-128 Encryption",
    "section": "AES Overview",
    "text": "AES Overview\nAES is a symmetric encryption algorithm that uses a specific key to both encrypt and decrypt data. It is the global standard for secure data encryption and is defined in three key sizes: AES-128, AES-192, and AES-256, where the number indicates the bit length of the cipher key. A larger key size provides stronger security but requires more hardware resources. AES encrypts data through a sequence of sub-algorithms and transformations that repeatedly mix the key with the plaintext to produce a ciphertext that appears random and cannot be reversed without the correct key. These transformations operate on matrices of bytes, with the key itself acting as one of the main transformation matrices. The encryption process consists of four main operations:\n\nSubBytes(): performs a non-linear byte substitution using a 16×16 S-box lookup table.\nshiftRows(): cyclically shifts the rows of the state matrix by varying offsets depending on row.\nmixColumns(): transforms each column of the state matrix using Galois Field arithmetic to further diffuse the data.\nAddRoundKey(): combines the current state with a round key using a bitwise XOR operation.\n\nFinally, these operations are repeated across multiple rounds of encryption, each using a different round key derived through an algorithm known as keyExpansion(). In the AES-128 implementation used in this lab, the encryption involves 10 rounds. Each round follows the sequence: AddRoundKey → SubBytes → ShiftRows → MixColumns, with the final round (10) skipping the MixColumns step."
  },
  {
    "objectID": "labs/lab7/lab7.html#experiment-setup-and-design-overview",
    "href": "labs/lab7/lab7.html#experiment-setup-and-design-overview",
    "title": "E155 Lab 7: Hardware Accelerated AES-128 Encryption",
    "section": "Experiment Setup and Design Overview",
    "text": "Experiment Setup and Design Overview\n\nMCU Setup\nThe MCU was already configured through the provided starter code. It was configured to implement the SPI mode 1. It was also set up as the master with an artificial chip select signal to allow 8-bit CE-based SPI decoding on the logic analyzers. The MCU controlled the internal signals that started the SPI transactions as well as checked results from the transactions. The MCU would set the signal load to the FPGA that prepares it to recieve inputs. The MCU then sends the plaintext and then the cipherkey and then would set load LOW to signal that all data is sent. During that period, the FPGA performs encryption and once all 10 rounds complete, the FPA sets the signal done HIGH so that the MCU prepares to receive the ciphertext. Once received, the MCU compared it to the expected cipher through a difference operation. If all operations yield zero, the green LED through PA9 would light up, otherwise the red LED at P10 lights up indicating that encryption didn’t work properly. This process was always triggered using the MCU reset that restarted the transactions.\n\n\nFPGA Setup\nSince all encryption was done by the FPGA, we had to write SystemVerilog modules to perform the transformation operations necessary for executing the AES encryption. A lot of these operations required heavy resource usage as operations such as key expansion are applied across a 128-bit word. This would always run the risk of exhausting LUTs and other FPGA resources. Therefore I had to take into account how my logic synthesized to ensure the implied hardware isn’t too heavy for the FPGA. The subBytes() lookup table was loaded into the FPGA embedded block RAMs which have the ability to store files upto 128kB. To ensure it is mapped properly to the EBRs, we used a clocked version of the AES byte substitution algorithm named sbox_sync(). This module could only parse an 8-bit word so in subBytes(), it was called 16 times to parse the full 128-bit word. The shiftRows() module performed some row permutation by rotating the 4 rows: row 0 was kept as is, row 1 was shifted left by 1, row 2 by 2, and row 3 by 3. After row permutation, mixColumns() treats each state as a four-byte vector and performs matrix multiplication (Galois field operations) on the bytes in a column withinin \\(GF(2^8)\\) followed by XOR operations to handle overflows. Next up is the addRoundKey() that performs XOR operations between the 128-bit word and the 128-bit key. Finally, I wrote down the module getNextKey() which performed the key expansion part of AES which receives a 128-bit key value and the tound constant, rcon, which is a series of 4-byte words used in the key schedule to create the sub-keys for each encryption round. The module would determine the key for the next round following the implementation and pseudocode provided in the standards document.\nAll the submodules described above were combined in a module named aes_core() whose job was implement the encryption datapath. The datapath followed the structure described in the AES Overview section above. The module took in the load signal that is asserted by the MCU afte sending the plaintext and key, then initiated the process. For round 0, the plaintext is XORed with the key and the result is passed on to the next rounds. In rounds 1 to 9, the key is updated each round alongside the the input to the datapath. This input is represented in the code as state as it hold the intermediate states of the data in-between round. After round 10, the done signal is asserted to prepare the MCU to receive the cyphertext.\nUsing a synchronized sbox meant that it takes multiple cycles per round to process the data sequentially and safely propagate signals through the combinational logic. Therefore I used cycleCountto basically set when to take inputs, when to latch outputs and when to move to the next rounds. The cycle count was also to help account for the single cycle delay caused by subBytes(). Without it, the datapath would race and try to perform key operations before byte substitution stabilizes.\nTo run the setup, we implemented the aes() module that prompts both aes_core() and the aes_spi() module that executes SPI communication betweent both the MCU and the FPGA. The connection and signals between these modules is shown in Figure 1."
  },
  {
    "objectID": "labs/lab7/lab7.html#design-implementation",
    "href": "labs/lab7/lab7.html#design-implementation",
    "title": "E155 Lab 7: Hardware Accelerated AES-128 Encryption",
    "section": "Design Implementation",
    "text": "Design Implementation\nThe modules to enforce the AES encryption and those that control the respective encryption transformation algorithms were written in SystemVerilog to run on the FPGA. To ensure proper communication and signal control between the MCU and FPGA, all signals followed the hierachy in the block diagram below:\n\n\n\n\n\n\nFigure 1: Hierachical Block Diagram\n\n\n\nAfter running the simulation ensuring modules work as expected, the full setup was installed on the development board. The board has DIP switches that connect specific MCU pins to specific FPGA pins which reduces the need for crossing wires. Other necessary signals like the LEDs were setup on a side breadboard. The complete setup is shown in the following schematic:\n\n\n\n\n\n\nFigure 2: AES encryption Wiring Setup"
  },
  {
    "objectID": "labs/lab7/lab7.html#hardware-testing",
    "href": "labs/lab7/lab7.html#hardware-testing",
    "title": "E155 Lab 7: Hardware Accelerated AES-128 Encryption",
    "section": "Hardware Testing",
    "text": "Hardware Testing\nThe testbenches were extremely helpful, especially for this particular lab. I was able to track how my key and other signals move around as I’m performing the key expansion. It allowed me to see how each data signal is loaded as well as when it is updated and it was how I realized the subBytes() issue. They were also essential in testing the modules that I had to write for this lab to ensure that the AES transformation modules function as expected. Each testbench was ran using examples from the NIST:197 Examples as well as other random hex values to check with more tests as possible. The testbenches for all relevant modules are shown in the figures below:\n\n\n\n\n\n\nFigure 3: subBytes() Simulation Waves\n\n\n\n\n\n\n\n\n\nFigure 4: shiftRows() Simulation Waves\n\n\n\n\n\n\n\n\n\nFigure 5: addRoundKey() Simulation Waves\n\n\n\n\n\n\n\n\n\nFigure 6: key generation (getNextKey()) Simulation Waves\n\n\n\n\n\n\n\n\n\nFigure 7: AES Key Expansion and Encryption Implementation\n\n\n\n\n\n\n\n\n\nFigure 8: MCU → FPGA SPI Transaction Simulation\n\n\n\nAs shown from all the different tests and cases above, the hardware-accelerated AES logic is valid. To test the hardware, I used the a logic analyzer to visualize the SPI transactions and check the data shared between the MCU and the FPGA. The resulting waves are shown below:\n\n\n\n\n\n\nFigure 9: Example SPI Transaction on Logic Analyzer"
  },
  {
    "objectID": "labs/lab7/lab7.html#conclusion",
    "href": "labs/lab7/lab7.html#conclusion",
    "title": "E155 Lab 7: Hardware Accelerated AES-128 Encryption",
    "section": "Conclusion",
    "text": "Conclusion\nThis lab took around 18 hours to complete. I lost a lot of time when implementing the key expansion logic because since I was using a split word (4x32) as opposed to the full 128-bit word it meant that my rotation had to apply to the “MSB” word. The standard states you rotate the “first word” but my interpretation of that led me to rotate the “LSB word” which was wrong. The second issue was that I didn’t implement properly the desired delay to help the subBytes() output stabilize therefore I was using wrong data in other blocks, sometimes not even have any data, especially in the first round (round0) and the middle round (round 5). I solved the issue by using a cycle counter, using a register to store intermediate round values. It was amazing to learn the logic and intuition behing the Advanced Encryption Standard."
  },
  {
    "objectID": "labs/lab7/lab7.html#ai-prototype-summary",
    "href": "labs/lab7/lab7.html#ai-prototype-summary",
    "title": "E155 Lab 7: Hardware Accelerated AES-128 Encryption",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n// -----------------------------------------------------------------------------\n// AES-128 Key Expansion: single \"round step\"\n// next_key = KeyExpansion(prev_key, round_idx)\n// FIPS-197: w'[0] = w[0] ^ (SubWord(RotWord(w[3])) ^ Rcon[i])\n//           w'[1] = w[1] ^ w'[0]\n//           w'[2] = w[2] ^ w'[1]\n//           w'[3] = w[3] ^ w'[2]\n// Notes:\n// - prev_key and next_key are 4 words (w[0]..w[3]), each 32 bits.\n// - round_idx is 1..10 for AES-128.\n// - Rcon[i] is {rc, 8'h00, 8'h00, 8'h00} with rc sequence per FIPS-197.\n// -----------------------------------------------------------------------------\nmodule aes128_key_expand_round\n(\n    input  logic [3:0][31:0] prev_key,     // prev_key[0] is w[0] (MS 32 bits), prev_key[3] is w[3] (LS 32 bits)\n    input  logic [3:0]       round_idx,    // valid: 1..10\n    output logic [3:0][31:0] next_key\n);\n\n    // --- g() = SubWord(RotWord(w[3])) ^ Rcon[i] ---\n    logic [31:0] w3_rot;\n    logic [31:0] w3_sub;\n    logic [31:0] rcon_word;\n    logic [31:0] gword;\n\n    // Assume these two modules are provided elsewhere and are purely combinational:\n    // RotWord: rotates left by 8 bits: {w[23:0], w[31:24]}\n    // SubWord: applies the S-box to each byte of the word\n    RotWord u_rot  (.in(prev_key[3]), .out(w3_rot));\n    SubWord u_sub  (.in(w3_rot),      .out(w3_sub));\n\n    // Rcon lookup (top byte only; other bytes are 0)\n    always_comb begin\n        unique case (round_idx)\n            4'd1:  rcon_word = 32'h01_00_00_00;\n            4'd2:  rcon_word = 32'h02_00_00_00;\n            4'd3:  rcon_word = 32'h04_00_00_00;\n            4'd4:  rcon_word = 32'h08_00_00_00;\n            4'd5:  rcon_word = 32'h10_00_00_00;\n            4'd6:  rcon_word = 32'h20_00_00_00;\n            4'd7:  rcon_word = 32'h40_00_00_00;\n            4'd8:  rcon_word = 32'h80_00_00_00;\n            4'd9:  rcon_word = 32'h1B_00_00_00;\n            4'd10: rcon_word = 32'h36_00_00_00;\n            default: rcon_word = 32'h00_00_00_00; // safe default\n        endcase\n    end\n\n    assign gword = w3_sub ^ rcon_word;\n\n    // Next key words per FIPS-197\n    assign next_key[0] = prev_key[0] ^ gword;\n    assign next_key[1] = prev_key[1] ^ next_key[0];\n    assign next_key[2] = prev_key[2] ^ next_key[1];\n    assign next_key[3] = prev_key[3] ^ next_key[2];\n\nendmodule\nThe execution of the key expansion logic is valid and I was able to verify it with my testbench and surprisingly it passed on the first try which I would say is a first for an LLM writing a code like this. But then I guess that since it was specifically noted that this is AES, there is enough information on the internet for it to properly execute key expansion.\n// Assumptions about existing blocks:\n// module module1(input  logic [31:0] in, output logic [31:0] out);\n// module module2(input  logic [31:0] in, output logic [31:0] out);\n\nmodule key_schedule #(\n    parameter int NK = 4,   // number of initial 32-bit words from key\n    parameter int NR = 10   // number of \"rounds\" controlling total words\n) (\n    // key holds NK words, packed left-to-right as:\n    // key[32*NK-1 -: 32] = w[0], key[32*(NK-1)-1 -: 32] = w[1], ... (see slice below)\n    input  logic [32*NK-1:0] key,\n\n    // Rcon indexed by i/NK; must be large enough for max i\n    // Required length = (4*NR+3)/NK + 1 (integer division)\n    input  logic [31:0] Rcon [0:((4*NR+3)/NK)],\n\n    // Output schedule: words w[0 .. 4*NR+3], each 32-bit\n    output logic [31:0] w    [0:(4*NR+3)]\n);\n\n    localparam int MAX_I     = 4*NR + 3;\n    localparam bit NK_GT6    = (NK &gt; 6);\n\n    // Helper: extract the i-th 32-bit word from 'key' for i in [0..NK-1]\n    // w[i] &lt;- key[4*i .. 4*i+3]  (treating each w[i] as 32 bits)\n    function automatic logic [31:0] key_word(input int idx);\n        // Map i -&gt; 32-bit slice; here we choose MSB-first packing:\n        // key[32*NK-1 -: 32] = w[0], key[32*NK-33 -: 32] = w[1], ...\n        key_word = key[32*(NK-idx)-1 -: 32];\n    endfunction\n\n    // Unrolled construction of all words\n    genvar i;\n    generate\n        for (i = 0; i &lt;= MAX_I; i++) begin : gen_words\n            if (i &lt; NK) begin : init_words\n                // Initialization: w[i] &lt;- key[4*i..4*i+3]\n                always_comb w[i] = key_word(i);\n            end\n            else begin : recur_words\n                // temp &lt;- w[i-1]\n                logic [31:0] temp0;\n                logic [31:0] after_m2;\n                logic [31:0] after_m1;\n                logic [31:0] after_m1_only;\n                logic [31:0] temp_sel;\n\n                // Previous word\n                always_comb temp0 = w[i-1];\n\n                // Instantiate transforms only where needed (compile-time conditions)\n                if ((i % NK) == 0) begin : do_m2_then_m1_and_xor_rcon\n                    module2 u_m2 (.in(temp0), .out(after_m2));\n                    module1 u_m1 (.in(after_m2), .out(after_m1));\n                    // temp &lt;- module1(module2(temp)) (+) Rcon[i/NK]\n                    always_comb temp_sel = after_m1 ^ Rcon[i / NK];\n                end\n                else if (NK_GT6 && ((i % NK) == 4)) begin : do_m1_only\n                    module1 u_m1_only (.in(temp0), .out(after_m1_only));\n                    // temp &lt;- module1(temp)\n                    always_comb temp_sel = after_m1_only;\n                end\n                else begin : pass_through\n                    // temp unchanged\n                    always_comb temp_sel = temp0;\n                end\n\n                // w[i] &lt;- w[i-NK] (+) temp\n                always_comb w[i] = w[i-NK] ^ temp_sel;\n            end\n        end\n    endgenerate\n\nendmodule"
  }
]