---
title: "MechCrypt: Hardware-Encrypted Messaging System"
format:
  html:
    code-links:
      - text: "MechaCrypt Repository"
        href: https://github.com/chrwu17/MechaCrypt
        icon: github
---

## Task Allocation Summary

The work for the past days has been divided as follows: 

- Christian Wu works on MCU tasks, including web interface and request handling, message parsing, TRNG key generation, LCD,  and transfer/receiving communication protocols regarding either of the MCUs.

- Josaphat Ngoga works on FPGA tasks, including encryption/decryption, SPRAM read/write, message sending, bridge module, and FPGA modules to handle SPI communications, as well as relevant MCU drivers where this crosstalk is implemented. Also responsible for setting up various mechanical components.

We worked together in setting up all hardware: Relay and solenoid blocks for the actuation system, as well as LCD and ESP32866 wiring.

## Progress Summary

### FPGA Tasks and Modules

On the **sender side**, we have the following modules:

- **aesEncryption():** Receives a 128-bit plaintext block and key from MCU 1 and encrypts it, returning the ciphertext and signal to show encryption is done.

- **spramWrite():** Receives the 128-bit ciphertext and splices it into 8 blocks of 16 bits, and each is written into a specific SPRAM block. The module returns the base address to help the read function and a signal that shows SPRAM writing is done.

- **spramRead():** Starting from the base address received from spramWrite(), it sequentially reads the SPRAM block, reconstructing the 128-bit ciphertext.

- **msgSend():** Receives the ciphertext, splices it into 16 bytes, and sends one at a time, starting from the MSB bytes. It has a parameter that allows us to change the speed of the transfer clock.

All of these modules have been tested with respective testbenches to validate functionality and are combined into the **sender()** top module and interact as shown in the block diagram below:

![Sender Module Block Diagram](docs/midpoint/senderTop.png){#fig-senderBlockD .lightbox}

On the **receiver side**, we have the following modules:

**bridge():** Receives the 128-bit key and total message length (represented as 8-bit binary) from MCU 1, and sends them out to MCU 2. All are done through a custom SPI protocol that defines both MCUs as independent masters controlling their own SCK and CS lines

**aesDecryption():** Receives a reconstructed 128-bit ciphertext block and key from MCU 1 and decrypts it, returning the plaintext to MCU to decode and display.

**msgReceive():** Receiving module to be used in case the MCU proves tough to receive the bytes from the actuators. Receives the byte blocks following the tx_clk defined by the sender and reconstructs the full ciphertext for decryption.

All of these modules have been tested with respective testbenches to validate functionality and are combined into the **receiver()** top module and interact as shown in the block diagram below:

![Receiver Module Block Diagram](docs/midpoint/receiverTop.png){#fig-receiverBlockD .lightbox}

### MCU Tasks and Drivers
On the **sender side**, we have the following drivers:

**webpage.c:** Creates a sender webpage, where the user can write a message, and the webpage will convert it into 128-bit blocks of the ASCII text in hex. When the user hits send, this file will store each block of text and use TRNG to generate a random 128-bit key for each block that exists. It will then send an SPI transaction to the FPGA with the first block and wait for the FPGAâ€™s DONE signal to send subsequent blocks. 

Below is a demo result of what the sender website looks like:

![Receiver Module Block Diagram](docs/midpoint/senderWeb.png){#fig-senderWeb .lightbox}

**trng.c:** This file initializes TRNG and reads the randomly generated bits from it. 

**main.c:** This file sets up our clock and peripherals and calls upon the functions in webpage.c to execute the webpage. 

Below is a sample transaction:
